{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/riandasilva/vetreria/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _objectSpread from \"/Users/riandasilva/vetreria/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _classCallCheck from \"/Users/riandasilva/vetreria/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/riandasilva/vetreria/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Vector3, BufferAttribute, Box3, FrontSide, Matrix4 } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG } from './Constants.js';\nimport { buildPackedTree } from './buildFunctions.js';\nimport { raycast as _raycast, raycastFirst as _raycastFirst, shapecast as _shapecast, intersectsGeometry as _intersectsGeometry, setBuffer, clearBuffer } from './castFunctions.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { SeparatingAxisTriangle } from '../math/SeparatingAxisTriangle.js';\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { iterateOverTriangles, setTriangle } from '../utils/TriangleUtilities.js';\nimport { convertRaycastIntersect } from '../utils/GeometryRayIntersectUtilities.js';\nvar SKIP_GENERATION = Symbol('skip tree generation');\nvar aabb = /* @__PURE__ */new Box3();\nvar aabb2 = /* @__PURE__ */new Box3();\nvar tempMatrix = /* @__PURE__ */new Matrix4();\nvar obb = /* @__PURE__ */new OrientedBox();\nvar obb2 = /* @__PURE__ */new OrientedBox();\nvar temp = /* @__PURE__ */new Vector3();\nvar temp1 = /* @__PURE__ */new Vector3();\nvar temp2 = /* @__PURE__ */new Vector3();\nvar temp3 = /* @__PURE__ */new Vector3();\nvar temp4 = /* @__PURE__ */new Vector3();\nvar tempBox = /* @__PURE__ */new Box3();\nvar trianglePool = /* @__PURE__ */new PrimitivePool(function () {\n  return new SeparatingAxisTriangle();\n});\nexport var MeshBVH = /*#__PURE__*/function () {\n  _createClass(MeshBVH, null, [{\n    key: \"serialize\",\n    value: function serialize(bvh) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (options.isBufferGeometry) {\n        console.warn('MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature.');\n        return MeshBVH.serialize(arguments[0], {\n          cloneBuffers: arguments[2] === undefined ? true : arguments[2]\n        });\n      }\n\n      options = _objectSpread({\n        cloneBuffers: true\n      }, options);\n      var geometry = bvh.geometry;\n      var rootData = bvh._roots;\n      var indexAttribute = geometry.getIndex();\n      var result;\n\n      if (options.cloneBuffers) {\n        result = {\n          roots: rootData.map(function (root) {\n            return root.slice();\n          }),\n          index: indexAttribute.array.slice()\n        };\n      } else {\n        result = {\n          roots: rootData,\n          index: indexAttribute.array\n        };\n      }\n\n      return result;\n    }\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(data, geometry) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (typeof options === 'boolean') {\n        console.warn('MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature.');\n        return MeshBVH.deserialize(arguments[0], arguments[1], {\n          setIndex: arguments[2] === undefined ? true : arguments[2]\n        });\n      }\n\n      options = _objectSpread({\n        setIndex: true\n      }, options);\n      var index = data.index,\n          roots = data.roots;\n      var bvh = new MeshBVH(geometry, _objectSpread(_objectSpread({}, options), {}, {\n        [SKIP_GENERATION]: true\n      }));\n      bvh._roots = roots;\n\n      if (options.setIndex) {\n        var indexAttribute = geometry.getIndex();\n\n        if (indexAttribute === null) {\n          var newIndex = new BufferAttribute(data.index, 1, false);\n          geometry.setIndex(newIndex);\n        } else if (indexAttribute.array !== index) {\n          indexAttribute.array.set(index);\n          indexAttribute.needsUpdate = true;\n        }\n      }\n\n      return bvh;\n    }\n  }]);\n\n  function MeshBVH(geometry) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, MeshBVH);\n\n    if (!geometry.isBufferGeometry) {\n      throw new Error('MeshBVH: Only BufferGeometries are supported.');\n    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {\n      throw new Error('MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.');\n    } // default options\n\n\n    options = Object.assign({\n      strategy: CENTER,\n      maxDepth: 40,\n      maxLeafTris: 10,\n      verbose: true,\n      useSharedArrayBuffer: false,\n      setBoundingBox: true,\n      onProgress: null,\n      // undocumented options\n      // Whether to skip generating the tree. Used for deserialization.\n      [SKIP_GENERATION]: false\n    }, options);\n\n    if (options.useSharedArrayBuffer && typeof SharedArrayBuffer === 'undefined') {\n      throw new Error('MeshBVH: SharedArrayBuffer is not available.');\n    }\n\n    this._roots = null;\n\n    if (!options[SKIP_GENERATION]) {\n      this._roots = buildPackedTree(geometry, options);\n\n      if (!geometry.boundingBox && options.setBoundingBox) {\n        geometry.boundingBox = this.getBoundingBox(new Box3());\n      }\n    } // retain references to the geometry so we can use them it without having to\n    // take a geometry reference in every function.\n\n\n    this.geometry = geometry;\n  }\n\n  _createClass(MeshBVH, [{\n    key: \"refit\",\n    value: function refit() {\n      var nodeIndices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      if (nodeIndices && Array.isArray(nodeIndices)) {\n        nodeIndices = new Set(nodeIndices);\n      }\n\n      var geometry = this.geometry;\n      var indexArr = geometry.index.array;\n      var posAttr = geometry.attributes.position;\n      var posArr = posAttr.array; // support for an interleaved position buffer\n\n      var bufferOffset = posAttr.offset || 0;\n      var stride = 3;\n\n      if (posAttr.isInterleavedBufferAttribute) {\n        stride = posAttr.data.stride;\n      }\n\n      var buffer, uint32Array, uint16Array, float32Array;\n      var byteOffset = 0;\n      var roots = this._roots;\n\n      for (var i = 0, l = roots.length; i < l; i++) {\n        buffer = roots[i];\n        uint32Array = new Uint32Array(buffer);\n        uint16Array = new Uint16Array(buffer);\n        float32Array = new Float32Array(buffer);\n\n        _traverse(0, byteOffset);\n\n        byteOffset += buffer.byteLength;\n      }\n\n      function _traverse(node32Index, byteOffset) {\n        var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var node16Index = node32Index * 2;\n        var isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n\n        if (isLeaf) {\n          var offset = uint32Array[node32Index + 6];\n          var count = uint16Array[node16Index + 14];\n          var minx = Infinity;\n          var miny = Infinity;\n          var minz = Infinity;\n          var maxx = -Infinity;\n          var maxy = -Infinity;\n          var maxz = -Infinity;\n\n          for (var _i = 3 * offset, _l = 3 * (offset + count); _i < _l; _i++) {\n            var index = indexArr[_i] * stride + bufferOffset;\n            var x = posArr[index + 0];\n            var y = posArr[index + 1];\n            var z = posArr[index + 2];\n            if (x < minx) minx = x;\n            if (x > maxx) maxx = x;\n            if (y < miny) miny = y;\n            if (y > maxy) maxy = y;\n            if (z < minz) minz = z;\n            if (z > maxz) maxz = z;\n          }\n\n          if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {\n            float32Array[node32Index + 0] = minx;\n            float32Array[node32Index + 1] = miny;\n            float32Array[node32Index + 2] = minz;\n            float32Array[node32Index + 3] = maxx;\n            float32Array[node32Index + 4] = maxy;\n            float32Array[node32Index + 5] = maxz;\n            return true;\n          } else {\n            return false;\n          }\n        } else {\n          var left = node32Index + 8;\n          var right = uint32Array[node32Index + 6]; // the identifying node indices provided by the shapecast function include offsets of all\n          // root buffers to guarantee they're unique between roots so offset left and right indices here.\n\n          var offsetLeft = left + byteOffset;\n          var offsetRight = right + byteOffset;\n          var forceChildren = force;\n          var includesLeft = false;\n          var includesRight = false;\n\n          if (nodeIndices) {\n            // if we see that neither the left or right child are included in the set that need to be updated\n            // then we assume that all children need to be updated.\n            if (!forceChildren) {\n              includesLeft = nodeIndices.has(offsetLeft);\n              includesRight = nodeIndices.has(offsetRight);\n              forceChildren = !includesLeft && !includesRight;\n            }\n          } else {\n            includesLeft = true;\n            includesRight = true;\n          }\n\n          var traverseLeft = forceChildren || includesLeft;\n          var traverseRight = forceChildren || includesRight;\n          var leftChange = false;\n\n          if (traverseLeft) {\n            leftChange = _traverse(left, byteOffset, forceChildren);\n          }\n\n          var rightChange = false;\n\n          if (traverseRight) {\n            rightChange = _traverse(right, byteOffset, forceChildren);\n          }\n\n          var didChange = leftChange || rightChange;\n\n          if (didChange) {\n            for (var _i2 = 0; _i2 < 3; _i2++) {\n              var lefti = left + _i2;\n              var righti = right + _i2;\n              var minLeftValue = float32Array[lefti];\n              var maxLeftValue = float32Array[lefti + 3];\n              var minRightValue = float32Array[righti];\n              var maxRightValue = float32Array[righti + 3];\n              float32Array[node32Index + _i2] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n              float32Array[node32Index + _i2 + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n            }\n          }\n\n          return didChange;\n        }\n      }\n    }\n  }, {\n    key: \"traverse\",\n    value: function traverse(callback) {\n      var rootIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var buffer = this._roots[rootIndex];\n      var uint32Array = new Uint32Array(buffer);\n      var uint16Array = new Uint16Array(buffer);\n\n      _traverse(0);\n\n      function _traverse(node32Index) {\n        var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var node16Index = node32Index * 2;\n        var isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n\n        if (isLeaf) {\n          var offset = uint32Array[node32Index + 6];\n          var count = uint16Array[node16Index + 14];\n          callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);\n        } else {\n          // TODO: use node functions here\n          var left = node32Index + BYTES_PER_NODE / 4;\n          var right = uint32Array[node32Index + 6];\n          var splitAxis = uint32Array[node32Index + 7];\n          var stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);\n\n          if (!stopTraversal) {\n            _traverse(left, depth + 1);\n\n            _traverse(right, depth + 1);\n          }\n        }\n      }\n    }\n    /* Core Cast Functions */\n\n  }, {\n    key: \"raycast\",\n    value: function raycast(ray) {\n      var materialOrSide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FrontSide;\n      var roots = this._roots;\n      var geometry = this.geometry;\n      var intersects = [];\n      var isMaterial = materialOrSide.isMaterial;\n      var isArrayMaterial = Array.isArray(materialOrSide);\n      var groups = geometry.groups;\n      var side = isMaterial ? materialOrSide.side : materialOrSide;\n\n      for (var i = 0, l = roots.length; i < l; i++) {\n        var materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n        var startCount = intersects.length;\n        setBuffer(roots[i]);\n\n        _raycast(0, geometry, materialSide, ray, intersects);\n\n        clearBuffer();\n\n        if (isArrayMaterial) {\n          var materialIndex = groups[i].materialIndex;\n\n          for (var j = startCount, jl = intersects.length; j < jl; j++) {\n            intersects[j].face.materialIndex = materialIndex;\n          }\n        }\n      }\n\n      return intersects;\n    }\n  }, {\n    key: \"raycastFirst\",\n    value: function raycastFirst(ray) {\n      var materialOrSide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FrontSide;\n      var roots = this._roots;\n      var geometry = this.geometry;\n      var isMaterial = materialOrSide.isMaterial;\n      var isArrayMaterial = Array.isArray(materialOrSide);\n      var closestResult = null;\n      var groups = geometry.groups;\n      var side = isMaterial ? materialOrSide.side : materialOrSide;\n\n      for (var i = 0, l = roots.length; i < l; i++) {\n        var materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n        setBuffer(roots[i]);\n\n        var result = _raycastFirst(0, geometry, materialSide, ray);\n\n        clearBuffer();\n\n        if (result != null && (closestResult == null || result.distance < closestResult.distance)) {\n          closestResult = result;\n\n          if (isArrayMaterial) {\n            result.face.materialIndex = groups[i].materialIndex;\n          }\n        }\n      }\n\n      return closestResult;\n    }\n  }, {\n    key: \"intersectsGeometry\",\n    value: function intersectsGeometry(otherGeometry, geomToMesh) {\n      var geometry = this.geometry;\n      var result = false;\n\n      var _iterator = _createForOfIteratorHelper(this._roots),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var root = _step.value;\n          setBuffer(root);\n          result = _intersectsGeometry(0, geometry, otherGeometry, geomToMesh);\n          clearBuffer();\n\n          if (result) {\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return result;\n    }\n  }, {\n    key: \"shapecast\",\n    value: function shapecast(callbacks, _intersectsTriangleFunc, _orderNodesFunc) {\n      var geometry = this.geometry;\n\n      if (callbacks instanceof Function) {\n        if (_intersectsTriangleFunc) {\n          // Support the previous function signature that provided three sequential index buffer\n          // indices here.\n          var originalTriangleFunc = _intersectsTriangleFunc;\n\n          _intersectsTriangleFunc = function _intersectsTriangleFunc(tri, index, contained, depth) {\n            var i3 = index * 3;\n            return originalTriangleFunc(tri, i3, i3 + 1, i3 + 2, contained, depth);\n          };\n        }\n\n        callbacks = {\n          boundsTraverseOrder: _orderNodesFunc,\n          intersectsBounds: callbacks,\n          intersectsTriangle: _intersectsTriangleFunc,\n          intersectsRange: null\n        };\n        console.warn('MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.');\n      }\n\n      var triangle = trianglePool.getPrimitive();\n      var _callbacks = callbacks,\n          boundsTraverseOrder = _callbacks.boundsTraverseOrder,\n          intersectsBounds = _callbacks.intersectsBounds,\n          intersectsRange = _callbacks.intersectsRange,\n          intersectsTriangle = _callbacks.intersectsTriangle;\n\n      if (intersectsRange && intersectsTriangle) {\n        var originalIntersectsRange = intersectsRange;\n\n        intersectsRange = function intersectsRange(offset, count, contained, depth, nodeIndex) {\n          if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {\n            return iterateOverTriangles(offset, count, geometry, intersectsTriangle, contained, depth, triangle);\n          }\n\n          return true;\n        };\n      } else if (!intersectsRange) {\n        if (intersectsTriangle) {\n          intersectsRange = function intersectsRange(offset, count, contained, depth) {\n            return iterateOverTriangles(offset, count, geometry, intersectsTriangle, contained, depth, triangle);\n          };\n        } else {\n          intersectsRange = function intersectsRange(offset, count, contained) {\n            return contained;\n          };\n        }\n      }\n\n      var result = false;\n      var byteOffset = 0;\n\n      var _iterator2 = _createForOfIteratorHelper(this._roots),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var root = _step2.value;\n          setBuffer(root);\n          result = _shapecast(0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n          clearBuffer();\n\n          if (result) {\n            break;\n          }\n\n          byteOffset += root.byteLength;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      trianglePool.releasePrimitive(triangle);\n      return result;\n    }\n  }, {\n    key: \"bvhcast\",\n    value: function bvhcast(otherBvh, matrixToLocal, callbacks) {\n      // BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather\n      // than an approach that walks down the tree (see bvhcast.js file for more info).\n      var intersectsRanges = callbacks.intersectsRanges,\n          intersectsTriangles = callbacks.intersectsTriangles;\n      var indexAttr = this.geometry.index;\n      var positionAttr = this.geometry.attributes.position;\n      var otherIndexAttr = otherBvh.geometry.index;\n      var otherPositionAttr = otherBvh.geometry.attributes.position;\n      tempMatrix.copy(matrixToLocal).invert();\n      var triangle = trianglePool.getPrimitive();\n      var triangle2 = trianglePool.getPrimitive();\n\n      if (intersectsTriangles) {\n        var iterateOverDoubleTriangles = function iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n          for (var i2 = offset2, l2 = offset2 + count2; i2 < l2; i2++) {\n            setTriangle(triangle2, i2 * 3, otherIndexAttr, otherPositionAttr);\n            triangle2.a.applyMatrix4(matrixToLocal);\n            triangle2.b.applyMatrix4(matrixToLocal);\n            triangle2.c.applyMatrix4(matrixToLocal);\n            triangle2.needsUpdate = true;\n\n            for (var i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++) {\n              setTriangle(triangle, i1 * 3, indexAttr, positionAttr);\n              triangle.needsUpdate = true;\n\n              if (intersectsTriangles(triangle, triangle2, i1, i2, depth1, index1, depth2, index2)) {\n                return true;\n              }\n            }\n          }\n\n          return false;\n        };\n\n        if (intersectsRanges) {\n          var originalIntersectsRanges = intersectsRanges;\n\n          intersectsRanges = function intersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n            if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) {\n              return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);\n            }\n\n            return true;\n          };\n        } else {\n          intersectsRanges = iterateOverDoubleTriangles;\n        }\n      }\n\n      this.getBoundingBox(aabb2);\n      aabb2.applyMatrix4(matrixToLocal);\n      var result = this.shapecast({\n        intersectsBounds: function intersectsBounds(box) {\n          return aabb2.intersectsBox(box);\n        },\n        intersectsRange: function intersectsRange(offset1, count1, contained, depth1, nodeIndex1, box) {\n          aabb.copy(box);\n          aabb.applyMatrix4(tempMatrix);\n          return otherBvh.shapecast({\n            intersectsBounds: function intersectsBounds(box) {\n              return aabb.intersectsBox(box);\n            },\n            intersectsRange: function intersectsRange(offset2, count2, contained, depth2, nodeIndex2) {\n              return intersectsRanges(offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2);\n            }\n          });\n        }\n      });\n      trianglePool.releasePrimitive(triangle);\n      trianglePool.releasePrimitive(triangle2);\n      return result;\n    }\n    /* Derived Cast Functions */\n\n  }, {\n    key: \"intersectsBox\",\n    value: function intersectsBox(box, boxToMesh) {\n      obb.set(box.min, box.max, boxToMesh);\n      obb.needsUpdate = true;\n      return this.shapecast({\n        intersectsBounds: function intersectsBounds(box) {\n          return obb.intersectsBox(box);\n        },\n        intersectsTriangle: function intersectsTriangle(tri) {\n          return obb.intersectsTriangle(tri);\n        }\n      });\n    }\n  }, {\n    key: \"intersectsSphere\",\n    value: function intersectsSphere(sphere) {\n      return this.shapecast({\n        intersectsBounds: function intersectsBounds(box) {\n          return sphere.intersectsBox(box);\n        },\n        intersectsTriangle: function intersectsTriangle(tri) {\n          return tri.intersectsSphere(sphere);\n        }\n      });\n    }\n  }, {\n    key: \"closestPointToGeometry\",\n    value: function closestPointToGeometry(otherGeometry, geometryToBvh) {\n      var target1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var target2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var minThreshold = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var maxThreshold = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Infinity;\n\n      if (!otherGeometry.boundingBox) {\n        otherGeometry.computeBoundingBox();\n      }\n\n      obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n      obb.needsUpdate = true;\n      var geometry = this.geometry;\n      var pos = geometry.attributes.position;\n      var index = geometry.index;\n      var otherPos = otherGeometry.attributes.position;\n      var otherIndex = otherGeometry.index;\n      var triangle = trianglePool.getPrimitive();\n      var triangle2 = trianglePool.getPrimitive();\n      var tempTarget1 = temp1;\n      var tempTargetDest1 = temp2;\n      var tempTarget2 = null;\n      var tempTargetDest2 = null;\n\n      if (target2) {\n        tempTarget2 = temp3;\n        tempTargetDest2 = temp4;\n      }\n\n      var closestDistance = Infinity;\n      var closestDistanceTriIndex = null;\n      var closestDistanceOtherTriIndex = null;\n      tempMatrix.copy(geometryToBvh).invert();\n      obb2.matrix.copy(tempMatrix);\n      this.shapecast({\n        boundsTraverseOrder: function boundsTraverseOrder(box) {\n          return obb.distanceToBox(box);\n        },\n        intersectsBounds: function intersectsBounds(box, isLeaf, score) {\n          if (score < closestDistance && score < maxThreshold) {\n            // if we know the triangles of this bounds will be intersected next then\n            // save the bounds to use during triangle checks.\n            if (isLeaf) {\n              obb2.min.copy(box.min);\n              obb2.max.copy(box.max);\n              obb2.needsUpdate = true;\n            }\n\n            return true;\n          }\n\n          return false;\n        },\n        intersectsRange: function intersectsRange(offset, count) {\n          if (otherGeometry.boundsTree) {\n            // if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n            // the closest bounds in the other geometry to check.\n            return otherGeometry.boundsTree.shapecast({\n              boundsTraverseOrder: function boundsTraverseOrder(box) {\n                return obb2.distanceToBox(box);\n              },\n              intersectsBounds: function intersectsBounds(box, isLeaf, score) {\n                return score < closestDistance && score < maxThreshold;\n              },\n              intersectsRange: function intersectsRange(otherOffset, otherCount) {\n                for (var i2 = otherOffset * 3, l2 = (otherOffset + otherCount) * 3; i2 < l2; i2 += 3) {\n                  setTriangle(triangle2, i2, otherIndex, otherPos);\n                  triangle2.a.applyMatrix4(geometryToBvh);\n                  triangle2.b.applyMatrix4(geometryToBvh);\n                  triangle2.c.applyMatrix4(geometryToBvh);\n                  triangle2.needsUpdate = true;\n\n                  for (var i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n                    setTriangle(triangle, i, index, pos);\n                    triangle.needsUpdate = true;\n                    var dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n\n                    if (dist < closestDistance) {\n                      tempTargetDest1.copy(tempTarget1);\n\n                      if (tempTargetDest2) {\n                        tempTargetDest2.copy(tempTarget2);\n                      }\n\n                      closestDistance = dist;\n                      closestDistanceTriIndex = i / 3;\n                      closestDistanceOtherTriIndex = i2 / 3;\n                    } // stop traversal if we find a point that's under the given threshold\n\n\n                    if (dist < minThreshold) {\n                      return true;\n                    }\n                  }\n                }\n              }\n            });\n          } else {\n            // If no bounds tree then we'll just check every triangle.\n            var triCount = otherIndex ? otherIndex.count : otherPos.count;\n\n            for (var i2 = 0, l2 = triCount; i2 < l2; i2 += 3) {\n              setTriangle(triangle2, i2, otherIndex, otherPos);\n              triangle2.a.applyMatrix4(geometryToBvh);\n              triangle2.b.applyMatrix4(geometryToBvh);\n              triangle2.c.applyMatrix4(geometryToBvh);\n              triangle2.needsUpdate = true;\n\n              for (var i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n                setTriangle(triangle, i, index, pos);\n                triangle.needsUpdate = true;\n                var dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n\n                if (dist < closestDistance) {\n                  tempTargetDest1.copy(tempTarget1);\n\n                  if (tempTargetDest2) {\n                    tempTargetDest2.copy(tempTarget2);\n                  }\n\n                  closestDistance = dist;\n                  closestDistanceTriIndex = i / 3;\n                  closestDistanceOtherTriIndex = i2 / 3;\n                } // stop traversal if we find a point that's under the given threshold\n\n\n                if (dist < minThreshold) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      });\n      trianglePool.releasePrimitive(triangle);\n      trianglePool.releasePrimitive(triangle2);\n      if (closestDistance === Infinity) return null;\n      if (!target1.point) target1.point = tempTargetDest1.clone();else target1.point.copy(tempTargetDest1);\n      target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;\n\n      if (target2) {\n        if (!target2.point) target2.point = tempTargetDest2.clone();else target2.point.copy(tempTargetDest2);\n        target2.point.applyMatrix4(tempMatrix);\n        tempTargetDest1.applyMatrix4(tempMatrix);\n        target2.distance = tempTargetDest1.sub(target2.point).length();\n        target2.faceIndex = closestDistanceOtherTriIndex;\n      }\n\n      return target1;\n    }\n  }, {\n    key: \"closestPointToPoint\",\n    value: function closestPointToPoint(point) {\n      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var minThreshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var maxThreshold = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n      // early out if under minThreshold\n      // skip checking if over maxThreshold\n      // set minThreshold = maxThreshold to quickly check if a point is within a threshold\n      // returns Infinity if no value found\n      var minThresholdSq = minThreshold * minThreshold;\n      var maxThresholdSq = maxThreshold * maxThreshold;\n      var closestDistanceSq = Infinity;\n      var closestDistanceTriIndex = null;\n      this.shapecast({\n        boundsTraverseOrder: function boundsTraverseOrder(box) {\n          temp.copy(point).clamp(box.min, box.max);\n          return temp.distanceToSquared(point);\n        },\n        intersectsBounds: function intersectsBounds(box, isLeaf, score) {\n          return score < closestDistanceSq && score < maxThresholdSq;\n        },\n        intersectsTriangle: function intersectsTriangle(tri, triIndex) {\n          tri.closestPointToPoint(point, temp);\n          var distSq = point.distanceToSquared(temp);\n\n          if (distSq < closestDistanceSq) {\n            temp1.copy(temp);\n            closestDistanceSq = distSq;\n            closestDistanceTriIndex = triIndex;\n          }\n\n          if (distSq < minThresholdSq) {\n            return true;\n          } else {\n            return false;\n          }\n        }\n      });\n      if (closestDistanceSq === Infinity) return null;\n      var closestDistance = Math.sqrt(closestDistanceSq);\n      if (!target.point) target.point = temp1.clone();else target.point.copy(temp1);\n      target.distance = closestDistance, target.faceIndex = closestDistanceTriIndex;\n      return target;\n    }\n  }, {\n    key: \"getBoundingBox\",\n    value: function getBoundingBox(target) {\n      target.makeEmpty();\n      var roots = this._roots;\n      roots.forEach(function (buffer) {\n        arrayToBox(0, new Float32Array(buffer), tempBox);\n        target.union(tempBox);\n      });\n      return target;\n    }\n  }]);\n\n  return MeshBVH;\n}(); // Deprecation\n\nvar originalRaycast = MeshBVH.prototype.raycast;\n\nMeshBVH.prototype.raycast = function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  if (args[0].isMesh) {\n    console.warn('MeshBVH: The function signature and results frame for \"raycast\" has changed. See docs for new signature.');\n    var mesh = args[0],\n        raycaster = args[1],\n        ray = args[2],\n        intersects = args[3];\n    var results = originalRaycast.call(this, ray, mesh.material);\n    results.forEach(function (hit) {\n      hit = convertRaycastIntersect(hit, mesh, raycaster);\n\n      if (hit) {\n        intersects.push(hit);\n      }\n    });\n    return intersects;\n  } else {\n    return originalRaycast.apply(this, args);\n  }\n};\n\nvar originalRaycastFirst = MeshBVH.prototype.raycastFirst;\n\nMeshBVH.prototype.raycastFirst = function () {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  if (args[0].isMesh) {\n    console.warn('MeshBVH: The function signature and results frame for \"raycastFirst\" has changed. See docs for new signature.');\n    var mesh = args[0],\n        raycaster = args[1],\n        ray = args[2];\n    return convertRaycastIntersect(originalRaycastFirst.call(this, ray, mesh.material), mesh, raycaster);\n  } else {\n    return originalRaycastFirst.apply(this, args);\n  }\n};\n\nvar originalClosestPointToPoint = MeshBVH.prototype.closestPointToPoint;\n\nMeshBVH.prototype.closestPointToPoint = function () {\n  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    args[_key3] = arguments[_key3];\n  }\n\n  if (args[0].isMesh) {\n    console.warn('MeshBVH: The function signature and results frame for \"closestPointToPoint\" has changed. See docs for new signature.');\n    args.unshift();\n    var target = args[1];\n    var result = {};\n    args[1] = result;\n    originalClosestPointToPoint.apply(this, args);\n\n    if (target) {\n      target.copy(result.point);\n    }\n\n    return result.distance;\n  } else {\n    return originalClosestPointToPoint.apply(this, args);\n  }\n};\n\nvar originalClosestPointToGeometry = MeshBVH.prototype.closestPointToGeometry;\n\nMeshBVH.prototype.closestPointToGeometry = function () {\n  for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    args[_key4] = arguments[_key4];\n  }\n\n  var target1 = args[2];\n  var target2 = args[3];\n\n  if (target1 && target1.isVector3 || target2 && target2.isVector3) {\n    console.warn('MeshBVH: The function signature and results frame for \"closestPointToGeometry\" has changed. See docs for new signature.');\n    var result1 = {};\n    var result2 = {};\n    var geometryToBvh = args[1];\n    args[2] = result1;\n    args[3] = result2;\n    originalClosestPointToGeometry.apply(this, args);\n\n    if (target1) {\n      target1.copy(result1.point);\n    }\n\n    if (target2) {\n      target2.copy(result2.point).applyMatrix4(geometryToBvh);\n    }\n\n    return result1.distance;\n  } else {\n    return originalClosestPointToGeometry.apply(this, args);\n  }\n};\n\nvar originalRefit = MeshBVH.prototype.refit;\n\nMeshBVH.prototype.refit = function () {\n  for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    args[_key5] = arguments[_key5];\n  }\n\n  var nodeIndices = args[0];\n  var terminationIndices = args[1];\n\n  if (terminationIndices && (terminationIndices instanceof Set || Array.isArray(terminationIndices))) {\n    console.warn('MeshBVH: The function signature for \"refit\" has changed. See docs for new signature.');\n    var newNodeIndices = new Set();\n    terminationIndices.forEach(function (v) {\n      return newNodeIndices.add(v);\n    });\n\n    if (nodeIndices) {\n      nodeIndices.forEach(function (v) {\n        return newNodeIndices.add(v);\n      });\n    }\n\n    originalRefit.call(this, newNodeIndices);\n  } else {\n    originalRefit.apply(this, args);\n  }\n};\n\n['intersectsGeometry', 'shapecast', 'intersectsBox', 'intersectsSphere'].forEach(function (name) {\n  var originalFunc = MeshBVH.prototype[name];\n\n  MeshBVH.prototype[name] = function () {\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n\n    if (args[0] === null || args[0].isMesh) {\n      args.shift();\n      console.warn(\"MeshBVH: The function signature for \\\"\".concat(name, \"\\\" has changed and no longer takes Mesh. See docs for new signature.\"));\n    }\n\n    return originalFunc.apply(this, args);\n  };\n});","map":{"version":3,"sources":["/Users/riandasilva/vetreria/node_modules/three-mesh-bvh/src/core/MeshBVH.js"],"names":["Vector3","BufferAttribute","Box3","FrontSide","Matrix4","CENTER","BYTES_PER_NODE","IS_LEAFNODE_FLAG","buildPackedTree","raycast","raycastFirst","shapecast","intersectsGeometry","setBuffer","clearBuffer","OrientedBox","SeparatingAxisTriangle","PrimitivePool","arrayToBox","iterateOverTriangles","setTriangle","convertRaycastIntersect","SKIP_GENERATION","Symbol","aabb","aabb2","tempMatrix","obb","obb2","temp","temp1","temp2","temp3","temp4","tempBox","trianglePool","MeshBVH","bvh","options","isBufferGeometry","console","warn","serialize","arguments","cloneBuffers","undefined","geometry","rootData","_roots","indexAttribute","getIndex","result","roots","map","root","slice","index","array","data","deserialize","setIndex","newIndex","set","needsUpdate","Error","isInterleavedBufferAttribute","Object","assign","strategy","maxDepth","maxLeafTris","verbose","useSharedArrayBuffer","setBoundingBox","onProgress","SharedArrayBuffer","boundingBox","getBoundingBox","nodeIndices","Array","isArray","Set","indexArr","posAttr","attributes","position","posArr","bufferOffset","offset","stride","buffer","uint32Array","uint16Array","float32Array","byteOffset","i","l","length","Uint32Array","Uint16Array","Float32Array","_traverse","byteLength","node32Index","force","node16Index","isLeaf","count","minx","Infinity","miny","minz","maxx","maxy","maxz","x","y","z","left","right","offsetLeft","offsetRight","forceChildren","includesLeft","includesRight","has","traverseLeft","traverseRight","leftChange","rightChange","didChange","lefti","righti","minLeftValue","maxLeftValue","minRightValue","maxRightValue","callback","rootIndex","depth","splitAxis","stopTraversal","ray","materialOrSide","intersects","isMaterial","isArrayMaterial","groups","side","materialSide","materialIndex","startCount","j","jl","face","closestResult","distance","otherGeometry","geomToMesh","callbacks","_intersectsTriangleFunc","_orderNodesFunc","Function","originalTriangleFunc","tri","contained","i3","boundsTraverseOrder","intersectsBounds","intersectsTriangle","intersectsRange","triangle","getPrimitive","originalIntersectsRange","nodeIndex","releasePrimitive","otherBvh","matrixToLocal","intersectsRanges","intersectsTriangles","indexAttr","positionAttr","otherIndexAttr","otherPositionAttr","copy","invert","triangle2","iterateOverDoubleTriangles","offset1","count1","offset2","count2","depth1","index1","depth2","index2","i2","l2","a","applyMatrix4","b","c","i1","l1","originalIntersectsRanges","box","intersectsBox","nodeIndex1","nodeIndex2","boxToMesh","min","max","sphere","intersectsSphere","geometryToBvh","target1","target2","minThreshold","maxThreshold","computeBoundingBox","pos","otherPos","otherIndex","tempTarget1","tempTargetDest1","tempTarget2","tempTargetDest2","closestDistance","closestDistanceTriIndex","closestDistanceOtherTriIndex","matrix","distanceToBox","score","boundsTree","otherOffset","otherCount","dist","distanceToTriangle","triCount","point","clone","faceIndex","sub","target","minThresholdSq","maxThresholdSq","closestDistanceSq","clamp","distanceToSquared","triIndex","closestPointToPoint","distSq","Math","sqrt","makeEmpty","forEach","union","originalRaycast","prototype","args","isMesh","mesh","raycaster","results","call","material","hit","push","apply","originalRaycastFirst","originalClosestPointToPoint","unshift","originalClosestPointToGeometry","closestPointToGeometry","isVector3","result1","result2","originalRefit","refit","terminationIndices","newNodeIndices","v","add","name","originalFunc","shift"],"mappings":";;;;AAAA,SAASA,OAAT,EAAkBC,eAAlB,EAAmCC,IAAnC,EAAyCC,SAAzC,EAAoDC,OAApD,QAAmE,OAAnE;AACA,SAASC,MAAT,EAAiBC,cAAjB,EAAiCC,gBAAjC,QAAyD,gBAAzD;AACA,SAASC,eAAT,QAAgC,qBAAhC;AACA,SACCC,OAAO,IAAPA,QADD,EAECC,YAAY,IAAZA,aAFD,EAGCC,SAAS,IAATA,UAHD,EAICC,kBAAkB,IAAlBA,mBAJD,EAKCC,SALD,EAMCC,WAND,QAOO,oBAPP;AAQA,SAASC,WAAT,QAA4B,wBAA5B;AACA,SAASC,sBAAT,QAAuC,mCAAvC;AACA,SAASC,aAAT,QAA8B,2BAA9B;AACA,SAASC,UAAT,QAA2B,+BAA3B;AACA,SAASC,oBAAT,EAA+BC,WAA/B,QAAkD,+BAAlD;AACA,SAASC,uBAAT,QAAwC,2CAAxC;AAEA,IAAMC,eAAe,GAAGC,MAAM,CAAE,sBAAF,CAA9B;AAEA,IAAMC,IAAI,GAAG,eAAgB,IAAItB,IAAJ,EAA7B;AACA,IAAMuB,KAAK,GAAG,eAAgB,IAAIvB,IAAJ,EAA9B;AACA,IAAMwB,UAAU,GAAG,eAAgB,IAAItB,OAAJ,EAAnC;AACA,IAAMuB,GAAG,GAAG,eAAgB,IAAIZ,WAAJ,EAA5B;AACA,IAAMa,IAAI,GAAG,eAAgB,IAAIb,WAAJ,EAA7B;AACA,IAAMc,IAAI,GAAG,eAAgB,IAAI7B,OAAJ,EAA7B;AACA,IAAM8B,KAAK,GAAG,eAAgB,IAAI9B,OAAJ,EAA9B;AACA,IAAM+B,KAAK,GAAG,eAAgB,IAAI/B,OAAJ,EAA9B;AACA,IAAMgC,KAAK,GAAG,eAAgB,IAAIhC,OAAJ,EAA9B;AACA,IAAMiC,KAAK,GAAG,eAAgB,IAAIjC,OAAJ,EAA9B;AACA,IAAMkC,OAAO,GAAG,eAAgB,IAAIhC,IAAJ,EAAhC;AACA,IAAMiC,YAAY,GAAG,eAAgB,IAAIlB,aAAJ,CAAmB;AAAA,SAAM,IAAID,sBAAJ,EAAN;AAAA,CAAnB,CAArC;AAEA,WAAaoB,OAAb;AAAA;AAAA;AAAA,8BAEmBC,GAFnB,EAEuC;AAAA,UAAfC,OAAe,uEAAL,EAAK;;AAErC,UAAKA,OAAO,CAACC,gBAAb,EAAgC;AAE/BC,QAAAA,OAAO,CAACC,IAAR,CAAc,sGAAd;AAEA,eAAOL,OAAO,CAACM,SAAR,CACNC,SAAS,CAAE,CAAF,CADH,EAEN;AACCC,UAAAA,YAAY,EAAED,SAAS,CAAE,CAAF,CAAT,KAAmBE,SAAnB,GAA+B,IAA/B,GAAsCF,SAAS,CAAE,CAAF;AAD9D,SAFM,CAAP;AAOA;;AAEDL,MAAAA,OAAO;AACNM,QAAAA,YAAY,EAAE;AADR,SAEHN,OAFG,CAAP;AAKA,UAAMQ,QAAQ,GAAGT,GAAG,CAACS,QAArB;AACA,UAAMC,QAAQ,GAAGV,GAAG,CAACW,MAArB;AACA,UAAMC,cAAc,GAAGH,QAAQ,CAACI,QAAT,EAAvB;AACA,UAAIC,MAAJ;;AACA,UAAKb,OAAO,CAACM,YAAb,EAA4B;AAE3BO,QAAAA,MAAM,GAAG;AACRC,UAAAA,KAAK,EAAEL,QAAQ,CAACM,GAAT,CAAc,UAAAC,IAAI;AAAA,mBAAIA,IAAI,CAACC,KAAL,EAAJ;AAAA,WAAlB,CADC;AAERC,UAAAA,KAAK,EAAEP,cAAc,CAACQ,KAAf,CAAqBF,KAArB;AAFC,SAAT;AAKA,OAPD,MAOO;AAENJ,QAAAA,MAAM,GAAG;AACRC,UAAAA,KAAK,EAAEL,QADC;AAERS,UAAAA,KAAK,EAAEP,cAAc,CAACQ;AAFd,SAAT;AAKA;;AAED,aAAON,MAAP;AAEA;AA5CF;AAAA;AAAA,gCA8CqBO,IA9CrB,EA8C2BZ,QA9C3B,EA8CoD;AAAA,UAAfR,OAAe,uEAAL,EAAK;;AAElD,UAAK,OAAOA,OAAP,KAAmB,SAAxB,EAAoC;AAEnCE,QAAAA,OAAO,CAACC,IAAR,CAAc,wGAAd;AAEA,eAAOL,OAAO,CAACuB,WAAR,CACNhB,SAAS,CAAE,CAAF,CADH,EAENA,SAAS,CAAE,CAAF,CAFH,EAGN;AACCiB,UAAAA,QAAQ,EAAEjB,SAAS,CAAE,CAAF,CAAT,KAAmBE,SAAnB,GAA+B,IAA/B,GAAsCF,SAAS,CAAE,CAAF;AAD1D,SAHM,CAAP;AAQA;;AAEDL,MAAAA,OAAO;AACNsB,QAAAA,QAAQ,EAAE;AADJ,SAEHtB,OAFG,CAAP;AAhBkD,UAqB1CkB,KArB0C,GAqBzBE,IArByB,CAqB1CF,KArB0C;AAAA,UAqBnCJ,KArBmC,GAqBzBM,IArByB,CAqBnCN,KArBmC;AAsBlD,UAAMf,GAAG,GAAG,IAAID,OAAJ,CAAaU,QAAb,kCAA4BR,OAA5B;AAAqC,SAAEhB,eAAF,GAAqB;AAA1D,SAAZ;AACAe,MAAAA,GAAG,CAACW,MAAJ,GAAaI,KAAb;;AAEA,UAAKd,OAAO,CAACsB,QAAb,EAAwB;AAEvB,YAAMX,cAAc,GAAGH,QAAQ,CAACI,QAAT,EAAvB;;AACA,YAAKD,cAAc,KAAK,IAAxB,EAA+B;AAE9B,cAAMY,QAAQ,GAAG,IAAI5D,eAAJ,CAAqByD,IAAI,CAACF,KAA1B,EAAiC,CAAjC,EAAoC,KAApC,CAAjB;AACAV,UAAAA,QAAQ,CAACc,QAAT,CAAmBC,QAAnB;AAEA,SALD,MAKO,IAAKZ,cAAc,CAACQ,KAAf,KAAyBD,KAA9B,EAAsC;AAE5CP,UAAAA,cAAc,CAACQ,KAAf,CAAqBK,GAArB,CAA0BN,KAA1B;AACAP,UAAAA,cAAc,CAACc,WAAf,GAA6B,IAA7B;AAEA;AAED;;AAED,aAAO1B,GAAP;AAEA;AA1FF;;AA4FC,mBAAaS,QAAb,EAAsC;AAAA,QAAfR,OAAe,uEAAL,EAAK;;AAAA;;AAErC,QAAK,CAAEQ,QAAQ,CAACP,gBAAhB,EAAmC;AAElC,YAAM,IAAIyB,KAAJ,CAAW,+CAAX,CAAN;AAEA,KAJD,MAIO,IAAKlB,QAAQ,CAACU,KAAT,IAAkBV,QAAQ,CAACU,KAAT,CAAeS,4BAAtC,EAAqE;AAE3E,YAAM,IAAID,KAAJ,CAAW,+EAAX,CAAN;AAEA,KAVoC,CAYrC;;;AACA1B,IAAAA,OAAO,GAAG4B,MAAM,CAACC,MAAP,CAAe;AAExBC,MAAAA,QAAQ,EAAE/D,MAFc;AAGxBgE,MAAAA,QAAQ,EAAE,EAHc;AAIxBC,MAAAA,WAAW,EAAE,EAJW;AAKxBC,MAAAA,OAAO,EAAE,IALe;AAMxBC,MAAAA,oBAAoB,EAAE,KANE;AAOxBC,MAAAA,cAAc,EAAE,IAPQ;AAQxBC,MAAAA,UAAU,EAAE,IARY;AAUxB;AAEA;AACA,OAAEpD,eAAF,GAAqB;AAbG,KAAf,EAePgB,OAfO,CAAV;;AAiBA,QAAKA,OAAO,CAACkC,oBAAR,IAAgC,OAAOG,iBAAP,KAA6B,WAAlE,EAAgF;AAE/E,YAAM,IAAIX,KAAJ,CAAW,8CAAX,CAAN;AAEA;;AAED,SAAKhB,MAAL,GAAc,IAAd;;AACA,QAAK,CAAEV,OAAO,CAAEhB,eAAF,CAAd,EAAoC;AAEnC,WAAK0B,MAAL,GAAcxC,eAAe,CAAEsC,QAAF,EAAYR,OAAZ,CAA7B;;AAEA,UAAK,CAAEQ,QAAQ,CAAC8B,WAAX,IAA0BtC,OAAO,CAACmC,cAAvC,EAAwD;AAEvD3B,QAAAA,QAAQ,CAAC8B,WAAT,GAAuB,KAAKC,cAAL,CAAqB,IAAI3E,IAAJ,EAArB,CAAvB;AAEA;AAED,KA/CoC,CAiDrC;AACA;;;AACA,SAAK4C,QAAL,GAAgBA,QAAhB;AAEA;;AAjJF;AAAA;AAAA,4BAmJ6B;AAAA,UAArBgC,WAAqB,uEAAP,IAAO;;AAE3B,UAAKA,WAAW,IAAIC,KAAK,CAACC,OAAN,CAAeF,WAAf,CAApB,EAAmD;AAElDA,QAAAA,WAAW,GAAG,IAAIG,GAAJ,CAASH,WAAT,CAAd;AAEA;;AAED,UAAMhC,QAAQ,GAAG,KAAKA,QAAtB;AACA,UAAMoC,QAAQ,GAAGpC,QAAQ,CAACU,KAAT,CAAeC,KAAhC;AACA,UAAM0B,OAAO,GAAGrC,QAAQ,CAACsC,UAAT,CAAoBC,QAApC;AACA,UAAMC,MAAM,GAAGH,OAAO,CAAC1B,KAAvB,CAX2B,CAa3B;;AACA,UAAM8B,YAAY,GAAGJ,OAAO,CAACK,MAAR,IAAkB,CAAvC;AACA,UAAIC,MAAM,GAAG,CAAb;;AACA,UAAKN,OAAO,CAAClB,4BAAb,EAA4C;AAE3CwB,QAAAA,MAAM,GAAGN,OAAO,CAACzB,IAAR,CAAa+B,MAAtB;AAEA;;AAED,UAAIC,MAAJ,EAAYC,WAAZ,EAAyBC,WAAzB,EAAsCC,YAAtC;AACA,UAAIC,UAAU,GAAG,CAAjB;AACA,UAAM1C,KAAK,GAAG,KAAKJ,MAAnB;;AACA,WAAM,IAAI+C,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG5C,KAAK,CAAC6C,MAA3B,EAAmCF,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAAiD;AAEhDL,QAAAA,MAAM,GAAGtC,KAAK,CAAE2C,CAAF,CAAd;AACAJ,QAAAA,WAAW,GAAG,IAAIO,WAAJ,CAAiBR,MAAjB,CAAd;AACAE,QAAAA,WAAW,GAAG,IAAIO,WAAJ,CAAiBT,MAAjB,CAAd;AACAG,QAAAA,YAAY,GAAG,IAAIO,YAAJ,CAAkBV,MAAlB,CAAf;;AAEAW,QAAAA,SAAS,CAAE,CAAF,EAAKP,UAAL,CAAT;;AACAA,QAAAA,UAAU,IAAIJ,MAAM,CAACY,UAArB;AAEA;;AAED,eAASD,SAAT,CAAoBE,WAApB,EAAiCT,UAAjC,EAA6D;AAAA,YAAhBU,KAAgB,uEAAR,KAAQ;AAE5D,YAAMC,WAAW,GAAGF,WAAW,GAAG,CAAlC;AACA,YAAMG,MAAM,GAAGd,WAAW,CAAEa,WAAW,GAAG,EAAhB,CAAX,KAAoClG,gBAAnD;;AACA,YAAKmG,MAAL,EAAc;AAEb,cAAMlB,MAAM,GAAGG,WAAW,CAAEY,WAAW,GAAG,CAAhB,CAA1B;AACA,cAAMI,KAAK,GAAGf,WAAW,CAAEa,WAAW,GAAG,EAAhB,CAAzB;AAEA,cAAIG,IAAI,GAAGC,QAAX;AACA,cAAIC,IAAI,GAAGD,QAAX;AACA,cAAIE,IAAI,GAAGF,QAAX;AACA,cAAIG,IAAI,GAAG,CAAEH,QAAb;AACA,cAAII,IAAI,GAAG,CAAEJ,QAAb;AACA,cAAIK,IAAI,GAAG,CAAEL,QAAb;;AACA,eAAM,IAAId,EAAC,GAAG,IAAIP,MAAZ,EAAoBQ,EAAC,GAAG,KAAMR,MAAM,GAAGmB,KAAf,CAA9B,EAAsDZ,EAAC,GAAGC,EAA1D,EAA6DD,EAAC,EAA9D,EAAoE;AAEnE,gBAAMvC,KAAK,GAAG0B,QAAQ,CAAEa,EAAF,CAAR,GAAgBN,MAAhB,GAAyBF,YAAvC;AACA,gBAAM4B,CAAC,GAAG7B,MAAM,CAAE9B,KAAK,GAAG,CAAV,CAAhB;AACA,gBAAM4D,CAAC,GAAG9B,MAAM,CAAE9B,KAAK,GAAG,CAAV,CAAhB;AACA,gBAAM6D,CAAC,GAAG/B,MAAM,CAAE9B,KAAK,GAAG,CAAV,CAAhB;AAEA,gBAAK2D,CAAC,GAAGP,IAAT,EAAgBA,IAAI,GAAGO,CAAP;AAChB,gBAAKA,CAAC,GAAGH,IAAT,EAAgBA,IAAI,GAAGG,CAAP;AAEhB,gBAAKC,CAAC,GAAGN,IAAT,EAAgBA,IAAI,GAAGM,CAAP;AAChB,gBAAKA,CAAC,GAAGH,IAAT,EAAgBA,IAAI,GAAGG,CAAP;AAEhB,gBAAKC,CAAC,GAAGN,IAAT,EAAgBA,IAAI,GAAGM,CAAP;AAChB,gBAAKA,CAAC,GAAGH,IAAT,EAAgBA,IAAI,GAAGG,CAAP;AAEhB;;AAED,cACCxB,YAAY,CAAEU,WAAW,GAAG,CAAhB,CAAZ,KAAoCK,IAApC,IACAf,YAAY,CAAEU,WAAW,GAAG,CAAhB,CAAZ,KAAoCO,IADpC,IAEAjB,YAAY,CAAEU,WAAW,GAAG,CAAhB,CAAZ,KAAoCQ,IAFpC,IAIAlB,YAAY,CAAEU,WAAW,GAAG,CAAhB,CAAZ,KAAoCS,IAJpC,IAKAnB,YAAY,CAAEU,WAAW,GAAG,CAAhB,CAAZ,KAAoCU,IALpC,IAMApB,YAAY,CAAEU,WAAW,GAAG,CAAhB,CAAZ,KAAoCW,IAPrC,EAQE;AAEDrB,YAAAA,YAAY,CAAEU,WAAW,GAAG,CAAhB,CAAZ,GAAkCK,IAAlC;AACAf,YAAAA,YAAY,CAAEU,WAAW,GAAG,CAAhB,CAAZ,GAAkCO,IAAlC;AACAjB,YAAAA,YAAY,CAAEU,WAAW,GAAG,CAAhB,CAAZ,GAAkCQ,IAAlC;AAEAlB,YAAAA,YAAY,CAAEU,WAAW,GAAG,CAAhB,CAAZ,GAAkCS,IAAlC;AACAnB,YAAAA,YAAY,CAAEU,WAAW,GAAG,CAAhB,CAAZ,GAAkCU,IAAlC;AACApB,YAAAA,YAAY,CAAEU,WAAW,GAAG,CAAhB,CAAZ,GAAkCW,IAAlC;AAEA,mBAAO,IAAP;AAEA,WApBD,MAoBO;AAEN,mBAAO,KAAP;AAEA;AAED,SAvDD,MAuDO;AAEN,cAAMI,IAAI,GAAGf,WAAW,GAAG,CAA3B;AACA,cAAMgB,KAAK,GAAG5B,WAAW,CAAEY,WAAW,GAAG,CAAhB,CAAzB,CAHM,CAKN;AACA;;AACA,cAAMiB,UAAU,GAAGF,IAAI,GAAGxB,UAA1B;AACA,cAAM2B,WAAW,GAAGF,KAAK,GAAGzB,UAA5B;AACA,cAAI4B,aAAa,GAAGlB,KAApB;AACA,cAAImB,YAAY,GAAG,KAAnB;AACA,cAAIC,aAAa,GAAG,KAApB;;AAEA,cAAK9C,WAAL,EAAmB;AAElB;AACA;AACA,gBAAK,CAAE4C,aAAP,EAAuB;AAEtBC,cAAAA,YAAY,GAAG7C,WAAW,CAAC+C,GAAZ,CAAiBL,UAAjB,CAAf;AACAI,cAAAA,aAAa,GAAG9C,WAAW,CAAC+C,GAAZ,CAAiBJ,WAAjB,CAAhB;AACAC,cAAAA,aAAa,GAAG,CAAEC,YAAF,IAAkB,CAAEC,aAApC;AAEA;AAED,WAZD,MAYO;AAEND,YAAAA,YAAY,GAAG,IAAf;AACAC,YAAAA,aAAa,GAAG,IAAhB;AAEA;;AAED,cAAME,YAAY,GAAGJ,aAAa,IAAIC,YAAtC;AACA,cAAMI,aAAa,GAAGL,aAAa,IAAIE,aAAvC;AAEA,cAAII,UAAU,GAAG,KAAjB;;AACA,cAAKF,YAAL,EAAoB;AAEnBE,YAAAA,UAAU,GAAG3B,SAAS,CAAEiB,IAAF,EAAQxB,UAAR,EAAoB4B,aAApB,CAAtB;AAEA;;AAED,cAAIO,WAAW,GAAG,KAAlB;;AACA,cAAKF,aAAL,EAAqB;AAEpBE,YAAAA,WAAW,GAAG5B,SAAS,CAAEkB,KAAF,EAASzB,UAAT,EAAqB4B,aAArB,CAAvB;AAEA;;AAED,cAAMQ,SAAS,GAAGF,UAAU,IAAIC,WAAhC;;AACA,cAAKC,SAAL,EAAiB;AAEhB,iBAAM,IAAInC,GAAC,GAAG,CAAd,EAAiBA,GAAC,GAAG,CAArB,EAAwBA,GAAC,EAAzB,EAA+B;AAE9B,kBAAMoC,KAAK,GAAGb,IAAI,GAAGvB,GAArB;AACA,kBAAMqC,MAAM,GAAGb,KAAK,GAAGxB,GAAvB;AACA,kBAAMsC,YAAY,GAAGxC,YAAY,CAAEsC,KAAF,CAAjC;AACA,kBAAMG,YAAY,GAAGzC,YAAY,CAAEsC,KAAK,GAAG,CAAV,CAAjC;AACA,kBAAMI,aAAa,GAAG1C,YAAY,CAAEuC,MAAF,CAAlC;AACA,kBAAMI,aAAa,GAAG3C,YAAY,CAAEuC,MAAM,GAAG,CAAX,CAAlC;AAEAvC,cAAAA,YAAY,CAAEU,WAAW,GAAGR,GAAhB,CAAZ,GAAkCsC,YAAY,GAAGE,aAAf,GAA+BF,YAA/B,GAA8CE,aAAhF;AACA1C,cAAAA,YAAY,CAAEU,WAAW,GAAGR,GAAd,GAAkB,CAApB,CAAZ,GAAsCuC,YAAY,GAAGE,aAAf,GAA+BF,YAA/B,GAA8CE,aAApF;AAEA;AAED;;AAED,iBAAON,SAAP;AAEA;AAED;AAED;AA7TF;AAAA;AAAA,6BA+TWO,QA/TX,EA+TqC;AAAA,UAAhBC,SAAgB,uEAAJ,CAAI;AAEnC,UAAMhD,MAAM,GAAG,KAAK1C,MAAL,CAAa0F,SAAb,CAAf;AACA,UAAM/C,WAAW,GAAG,IAAIO,WAAJ,CAAiBR,MAAjB,CAApB;AACA,UAAME,WAAW,GAAG,IAAIO,WAAJ,CAAiBT,MAAjB,CAApB;;AACAW,MAAAA,SAAS,CAAE,CAAF,CAAT;;AAEA,eAASA,SAAT,CAAoBE,WAApB,EAA6C;AAAA,YAAZoC,KAAY,uEAAJ,CAAI;AAE5C,YAAMlC,WAAW,GAAGF,WAAW,GAAG,CAAlC;AACA,YAAMG,MAAM,GAAGd,WAAW,CAAEa,WAAW,GAAG,EAAhB,CAAX,KAAoClG,gBAAnD;;AACA,YAAKmG,MAAL,EAAc;AAEb,cAAMlB,MAAM,GAAGG,WAAW,CAAEY,WAAW,GAAG,CAAhB,CAA1B;AACA,cAAMI,KAAK,GAAGf,WAAW,CAAEa,WAAW,GAAG,EAAhB,CAAzB;AACAgC,UAAAA,QAAQ,CAAEE,KAAF,EAASjC,MAAT,EAAiB,IAAIN,YAAJ,CAAkBV,MAAlB,EAA0Ba,WAAW,GAAG,CAAxC,EAA2C,CAA3C,CAAjB,EAAiEf,MAAjE,EAAyEmB,KAAzE,CAAR;AAEA,SAND,MAMO;AAEN;AACA,cAAMW,IAAI,GAAGf,WAAW,GAAGjG,cAAc,GAAG,CAA5C;AACA,cAAMiH,KAAK,GAAG5B,WAAW,CAAEY,WAAW,GAAG,CAAhB,CAAzB;AACA,cAAMqC,SAAS,GAAGjD,WAAW,CAAEY,WAAW,GAAG,CAAhB,CAA7B;AACA,cAAMsC,aAAa,GAAGJ,QAAQ,CAAEE,KAAF,EAASjC,MAAT,EAAiB,IAAIN,YAAJ,CAAkBV,MAAlB,EAA0Ba,WAAW,GAAG,CAAxC,EAA2C,CAA3C,CAAjB,EAAiEqC,SAAjE,CAA9B;;AAEA,cAAK,CAAEC,aAAP,EAAuB;AAEtBxC,YAAAA,SAAS,CAAEiB,IAAF,EAAQqB,KAAK,GAAG,CAAhB,CAAT;;AACAtC,YAAAA,SAAS,CAAEkB,KAAF,EAASoB,KAAK,GAAG,CAAjB,CAAT;AAEA;AAED;AAED;AAED;AAED;;AArWD;AAAA;AAAA,4BAsWUG,GAtWV,EAsW4C;AAAA,UAA7BC,cAA6B,uEAAZ5I,SAAY;AAE1C,UAAMiD,KAAK,GAAG,KAAKJ,MAAnB;AACA,UAAMF,QAAQ,GAAG,KAAKA,QAAtB;AACA,UAAMkG,UAAU,GAAG,EAAnB;AACA,UAAMC,UAAU,GAAGF,cAAc,CAACE,UAAlC;AACA,UAAMC,eAAe,GAAGnE,KAAK,CAACC,OAAN,CAAe+D,cAAf,CAAxB;AAEA,UAAMI,MAAM,GAAGrG,QAAQ,CAACqG,MAAxB;AACA,UAAMC,IAAI,GAAGH,UAAU,GAAGF,cAAc,CAACK,IAAlB,GAAyBL,cAAhD;;AACA,WAAM,IAAIhD,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG5C,KAAK,CAAC6C,MAA3B,EAAmCF,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAAiD;AAEhD,YAAMsD,YAAY,GAAGH,eAAe,GAAGH,cAAc,CAAEI,MAAM,CAAEpD,CAAF,CAAN,CAAYuD,aAAd,CAAd,CAA4CF,IAA/C,GAAsDA,IAA1F;AACA,YAAMG,UAAU,GAAGP,UAAU,CAAC/C,MAA9B;AAEApF,QAAAA,SAAS,CAAEuC,KAAK,CAAE2C,CAAF,CAAP,CAAT;;AACAtF,QAAAA,QAAO,CAAE,CAAF,EAAKqC,QAAL,EAAeuG,YAAf,EAA6BP,GAA7B,EAAkCE,UAAlC,CAAP;;AACAlI,QAAAA,WAAW;;AAEX,YAAKoI,eAAL,EAAuB;AAEtB,cAAMI,aAAa,GAAGH,MAAM,CAAEpD,CAAF,CAAN,CAAYuD,aAAlC;;AACA,eAAM,IAAIE,CAAC,GAAGD,UAAR,EAAoBE,EAAE,GAAGT,UAAU,CAAC/C,MAA1C,EAAkDuD,CAAC,GAAGC,EAAtD,EAA0DD,CAAC,EAA3D,EAAiE;AAEhER,YAAAA,UAAU,CAAEQ,CAAF,CAAV,CAAgBE,IAAhB,CAAqBJ,aAArB,GAAqCA,aAArC;AAEA;AAED;AAED;;AAED,aAAON,UAAP;AAEA;AAxYF;AAAA;AAAA,iCA0YeF,GA1Yf,EA0YiD;AAAA,UAA7BC,cAA6B,uEAAZ5I,SAAY;AAE/C,UAAMiD,KAAK,GAAG,KAAKJ,MAAnB;AACA,UAAMF,QAAQ,GAAG,KAAKA,QAAtB;AACA,UAAMmG,UAAU,GAAGF,cAAc,CAACE,UAAlC;AACA,UAAMC,eAAe,GAAGnE,KAAK,CAACC,OAAN,CAAe+D,cAAf,CAAxB;AAEA,UAAIY,aAAa,GAAG,IAApB;AAEA,UAAMR,MAAM,GAAGrG,QAAQ,CAACqG,MAAxB;AACA,UAAMC,IAAI,GAAGH,UAAU,GAAGF,cAAc,CAACK,IAAlB,GAAyBL,cAAhD;;AACA,WAAM,IAAIhD,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG5C,KAAK,CAAC6C,MAA3B,EAAmCF,CAAC,GAAGC,CAAvC,EAA0CD,CAAC,EAA3C,EAAiD;AAEhD,YAAMsD,YAAY,GAAGH,eAAe,GAAGH,cAAc,CAAEI,MAAM,CAAEpD,CAAF,CAAN,CAAYuD,aAAd,CAAd,CAA4CF,IAA/C,GAAsDA,IAA1F;AAEAvI,QAAAA,SAAS,CAAEuC,KAAK,CAAE2C,CAAF,CAAP,CAAT;;AACA,YAAM5C,MAAM,GAAGzC,aAAY,CAAE,CAAF,EAAKoC,QAAL,EAAeuG,YAAf,EAA6BP,GAA7B,CAA3B;;AACAhI,QAAAA,WAAW;;AAEX,YAAKqC,MAAM,IAAI,IAAV,KAAoBwG,aAAa,IAAI,IAAjB,IAAyBxG,MAAM,CAACyG,QAAP,GAAkBD,aAAa,CAACC,QAA7E,CAAL,EAA+F;AAE9FD,UAAAA,aAAa,GAAGxG,MAAhB;;AACA,cAAK+F,eAAL,EAAuB;AAEtB/F,YAAAA,MAAM,CAACuG,IAAP,CAAYJ,aAAZ,GAA4BH,MAAM,CAAEpD,CAAF,CAAN,CAAYuD,aAAxC;AAEA;AAED;AAED;;AAED,aAAOK,aAAP;AAEA;AA5aF;AAAA;AAAA,uCA8aqBE,aA9arB,EA8aoCC,UA9apC,EA8aiD;AAE/C,UAAMhH,QAAQ,GAAG,KAAKA,QAAtB;AACA,UAAIK,MAAM,GAAG,KAAb;;AAH+C,iDAI3B,KAAKH,MAJsB;AAAA;;AAAA;AAI/C,4DAAkC;AAAA,cAAtBM,IAAsB;AAEjCzC,UAAAA,SAAS,CAAEyC,IAAF,CAAT;AACAH,UAAAA,MAAM,GAAGvC,mBAAkB,CAAE,CAAF,EAAKkC,QAAL,EAAe+G,aAAf,EAA8BC,UAA9B,CAA3B;AACAhJ,UAAAA,WAAW;;AAEX,cAAKqC,MAAL,EAAc;AAEb;AAEA;AAED;AAhB8C;AAAA;AAAA;AAAA;AAAA;;AAkB/C,aAAOA,MAAP;AAEA;AAlcF;AAAA;AAAA,8BAocY4G,SApcZ,EAocuBC,uBApcvB,EAocgDC,eApchD,EAockE;AAEhE,UAAMnH,QAAQ,GAAG,KAAKA,QAAtB;;AACA,UAAKiH,SAAS,YAAYG,QAA1B,EAAqC;AAEpC,YAAKF,uBAAL,EAA+B;AAE9B;AACA;AACA,cAAMG,oBAAoB,GAAGH,uBAA7B;;AACAA,UAAAA,uBAAuB,GAAG,iCAAEI,GAAF,EAAO5G,KAAP,EAAc6G,SAAd,EAAyB1B,KAAzB,EAAoC;AAE7D,gBAAM2B,EAAE,GAAG9G,KAAK,GAAG,CAAnB;AACA,mBAAO2G,oBAAoB,CAAEC,GAAF,EAAOE,EAAP,EAAWA,EAAE,GAAG,CAAhB,EAAmBA,EAAE,GAAG,CAAxB,EAA2BD,SAA3B,EAAsC1B,KAAtC,CAA3B;AAEA,WALD;AAQA;;AAEDoB,QAAAA,SAAS,GAAG;AAEXQ,UAAAA,mBAAmB,EAAEN,eAFV;AAGXO,UAAAA,gBAAgB,EAAET,SAHP;AAIXU,UAAAA,kBAAkB,EAAET,uBAJT;AAKXU,UAAAA,eAAe,EAAE;AALN,SAAZ;AASAlI,QAAAA,OAAO,CAACC,IAAR,CAAc,0IAAd;AAEA;;AAED,UAAMkI,QAAQ,GAAGxI,YAAY,CAACyI,YAAb,EAAjB;AAjCgE,uBAuC5Db,SAvC4D;AAAA,UAmC/DQ,mBAnC+D,cAmC/DA,mBAnC+D;AAAA,UAoC/DC,gBApC+D,cAoC/DA,gBApC+D;AAAA,UAqC/DE,eArC+D,cAqC/DA,eArC+D;AAAA,UAsC/DD,kBAtC+D,cAsC/DA,kBAtC+D;;AAyChE,UAAKC,eAAe,IAAID,kBAAxB,EAA6C;AAE5C,YAAMI,uBAAuB,GAAGH,eAAhC;;AACAA,QAAAA,eAAe,GAAG,yBAAElF,MAAF,EAAUmB,KAAV,EAAiB0D,SAAjB,EAA4B1B,KAA5B,EAAmCmC,SAAnC,EAAkD;AAEnE,cAAK,CAAED,uBAAuB,CAAErF,MAAF,EAAUmB,KAAV,EAAiB0D,SAAjB,EAA4B1B,KAA5B,EAAmCmC,SAAnC,CAA9B,EAA+E;AAE9E,mBAAO3J,oBAAoB,CAAEqE,MAAF,EAAUmB,KAAV,EAAiB7D,QAAjB,EAA2B2H,kBAA3B,EAA+CJ,SAA/C,EAA0D1B,KAA1D,EAAiEgC,QAAjE,CAA3B;AAEA;;AAED,iBAAO,IAAP;AAEA,SAVD;AAYA,OAfD,MAeO,IAAK,CAAED,eAAP,EAAyB;AAE/B,YAAKD,kBAAL,EAA0B;AAEzBC,UAAAA,eAAe,GAAG,yBAAElF,MAAF,EAAUmB,KAAV,EAAiB0D,SAAjB,EAA4B1B,KAA5B,EAAuC;AAExD,mBAAOxH,oBAAoB,CAAEqE,MAAF,EAAUmB,KAAV,EAAiB7D,QAAjB,EAA2B2H,kBAA3B,EAA+CJ,SAA/C,EAA0D1B,KAA1D,EAAiEgC,QAAjE,CAA3B;AAEA,WAJD;AAMA,SARD,MAQO;AAEND,UAAAA,eAAe,GAAG,yBAAElF,MAAF,EAAUmB,KAAV,EAAiB0D,SAAjB,EAAgC;AAEjD,mBAAOA,SAAP;AAEA,WAJD;AAMA;AAED;;AAED,UAAIlH,MAAM,GAAG,KAAb;AACA,UAAI2C,UAAU,GAAG,CAAjB;;AA/EgE,kDAgF5C,KAAK9C,MAhFuC;AAAA;;AAAA;AAgFhE,+DAAkC;AAAA,cAAtBM,IAAsB;AAEjCzC,UAAAA,SAAS,CAAEyC,IAAF,CAAT;AACAH,UAAAA,MAAM,GAAGxC,UAAS,CAAE,CAAF,EAAKmC,QAAL,EAAe0H,gBAAf,EAAiCE,eAAjC,EAAkDH,mBAAlD,EAAuEzE,UAAvE,CAAlB;AACAhF,UAAAA,WAAW;;AAEX,cAAKqC,MAAL,EAAc;AAEb;AAEA;;AAED2C,UAAAA,UAAU,IAAIxC,IAAI,CAACgD,UAAnB;AAEA;AA9F+D;AAAA;AAAA;AAAA;AAAA;;AAgGhEnE,MAAAA,YAAY,CAAC4I,gBAAb,CAA+BJ,QAA/B;AAEA,aAAOxH,MAAP;AAEA;AAxiBF;AAAA;AAAA,4BA0iBU6H,QA1iBV,EA0iBoBC,aA1iBpB,EA0iBmClB,SA1iBnC,EA0iB+C;AAE7C;AACA;AAH6C,UAM5CmB,gBAN4C,GAQzCnB,SARyC,CAM5CmB,gBAN4C;AAAA,UAO5CC,mBAP4C,GAQzCpB,SARyC,CAO5CoB,mBAP4C;AAU7C,UAAMC,SAAS,GAAG,KAAKtI,QAAL,CAAcU,KAAhC;AACA,UAAM6H,YAAY,GAAG,KAAKvI,QAAL,CAAcsC,UAAd,CAAyBC,QAA9C;AAEA,UAAMiG,cAAc,GAAGN,QAAQ,CAAClI,QAAT,CAAkBU,KAAzC;AACA,UAAM+H,iBAAiB,GAAGP,QAAQ,CAAClI,QAAT,CAAkBsC,UAAlB,CAA6BC,QAAvD;AAEA3D,MAAAA,UAAU,CAAC8J,IAAX,CAAiBP,aAAjB,EAAiCQ,MAAjC;AAEA,UAAMd,QAAQ,GAAGxI,YAAY,CAACyI,YAAb,EAAjB;AACA,UAAMc,SAAS,GAAGvJ,YAAY,CAACyI,YAAb,EAAlB;;AAEA,UAAKO,mBAAL,EAA2B;AAAA,YAEjBQ,0BAFiB,GAE1B,SAASA,0BAAT,CAAqCC,OAArC,EAA8CC,MAA9C,EAAsDC,OAAtD,EAA+DC,MAA/D,EAAuEC,MAAvE,EAA+EC,MAA/E,EAAuFC,MAAvF,EAA+FC,MAA/F,EAAwG;AAEvG,eAAM,IAAIC,EAAE,GAAGN,OAAT,EAAkBO,EAAE,GAAGP,OAAO,GAAGC,MAAvC,EAA+CK,EAAE,GAAGC,EAApD,EAAwDD,EAAE,EAA1D,EAAgE;AAE/DhL,YAAAA,WAAW,CAAEsK,SAAF,EAAaU,EAAE,GAAG,CAAlB,EAAqBd,cAArB,EAAqCC,iBAArC,CAAX;AACAG,YAAAA,SAAS,CAACY,CAAV,CAAYC,YAAZ,CAA0BtB,aAA1B;AACAS,YAAAA,SAAS,CAACc,CAAV,CAAYD,YAAZ,CAA0BtB,aAA1B;AACAS,YAAAA,SAAS,CAACe,CAAV,CAAYF,YAAZ,CAA0BtB,aAA1B;AACAS,YAAAA,SAAS,CAAC3H,WAAV,GAAwB,IAAxB;;AAEA,iBAAM,IAAI2I,EAAE,GAAGd,OAAT,EAAkBe,EAAE,GAAGf,OAAO,GAAGC,MAAvC,EAA+Ca,EAAE,GAAGC,EAApD,EAAwDD,EAAE,EAA1D,EAAgE;AAE/DtL,cAAAA,WAAW,CAAEuJ,QAAF,EAAY+B,EAAE,GAAG,CAAjB,EAAoBtB,SAApB,EAA+BC,YAA/B,CAAX;AACAV,cAAAA,QAAQ,CAAC5G,WAAT,GAAuB,IAAvB;;AAEA,kBAAKoH,mBAAmB,CAAER,QAAF,EAAYe,SAAZ,EAAuBgB,EAAvB,EAA2BN,EAA3B,EAA+BJ,MAA/B,EAAuCC,MAAvC,EAA+CC,MAA/C,EAAuDC,MAAvD,CAAxB,EAA0F;AAEzF,uBAAO,IAAP;AAEA;AAED;AAED;;AAED,iBAAO,KAAP;AAEA,SA7ByB;;AA+B1B,YAAKjB,gBAAL,EAAwB;AAEvB,cAAM0B,wBAAwB,GAAG1B,gBAAjC;;AACAA,UAAAA,gBAAgB,GAAG,0BAAWU,OAAX,EAAoBC,MAApB,EAA4BC,OAA5B,EAAqCC,MAArC,EAA6CC,MAA7C,EAAqDC,MAArD,EAA6DC,MAA7D,EAAqEC,MAArE,EAA8E;AAEhG,gBAAK,CAAES,wBAAwB,CAAEhB,OAAF,EAAWC,MAAX,EAAmBC,OAAnB,EAA4BC,MAA5B,EAAoCC,MAApC,EAA4CC,MAA5C,EAAoDC,MAApD,EAA4DC,MAA5D,CAA/B,EAAsG;AAErG,qBAAOR,0BAA0B,CAAEC,OAAF,EAAWC,MAAX,EAAmBC,OAAnB,EAA4BC,MAA5B,EAAoCC,MAApC,EAA4CC,MAA5C,EAAoDC,MAApD,EAA4DC,MAA5D,CAAjC;AAEA;;AAED,mBAAO,IAAP;AAEA,WAVD;AAYA,SAfD,MAeO;AAENjB,UAAAA,gBAAgB,GAAGS,0BAAnB;AAEA;AAED;;AAED,WAAK9G,cAAL,CAAqBpD,KAArB;AACAA,MAAAA,KAAK,CAAC8K,YAAN,CAAoBtB,aAApB;AACA,UAAM9H,MAAM,GAAG,KAAKxC,SAAL,CAAgB;AAE9B6J,QAAAA,gBAAgB,EAAE,0BAAAqC,GAAG;AAAA,iBAAIpL,KAAK,CAACqL,aAAN,CAAqBD,GAArB,CAAJ;AAAA,SAFS;AAI9BnC,QAAAA,eAAe,EAAE,yBAAEkB,OAAF,EAAWC,MAAX,EAAmBxB,SAAnB,EAA8B2B,MAA9B,EAAsCe,UAAtC,EAAkDF,GAAlD,EAA2D;AAE3ErL,UAAAA,IAAI,CAACgK,IAAL,CAAWqB,GAAX;AACArL,UAAAA,IAAI,CAAC+K,YAAL,CAAmB7K,UAAnB;AACA,iBAAOsJ,QAAQ,CAACrK,SAAT,CAAoB;AAE1B6J,YAAAA,gBAAgB,EAAE,0BAAAqC,GAAG;AAAA,qBAAIrL,IAAI,CAACsL,aAAL,CAAoBD,GAApB,CAAJ;AAAA,aAFK;AAI1BnC,YAAAA,eAAe,EAAE,yBAAEoB,OAAF,EAAWC,MAAX,EAAmB1B,SAAnB,EAA8B6B,MAA9B,EAAsCc,UAAtC,EAAsD;AAEtE,qBAAO9B,gBAAgB,CAAEU,OAAF,EAAWC,MAAX,EAAmBC,OAAnB,EAA4BC,MAA5B,EAAoCC,MAApC,EAA4Ce,UAA5C,EAAwDb,MAAxD,EAAgEc,UAAhE,CAAvB;AAEA;AARyB,WAApB,CAAP;AAYA;AApB6B,OAAhB,CAAf;AAwBA7K,MAAAA,YAAY,CAAC4I,gBAAb,CAA+BJ,QAA/B;AACAxI,MAAAA,YAAY,CAAC4I,gBAAb,CAA+BW,SAA/B;AACA,aAAOvI,MAAP;AAEA;AAED;;AArpBD;AAAA;AAAA,kCAspBgB0J,GAtpBhB,EAspBqBI,SAtpBrB,EAspBiC;AAE/BtL,MAAAA,GAAG,CAACmC,GAAJ,CAAS+I,GAAG,CAACK,GAAb,EAAkBL,GAAG,CAACM,GAAtB,EAA2BF,SAA3B;AACAtL,MAAAA,GAAG,CAACoC,WAAJ,GAAkB,IAAlB;AAEA,aAAO,KAAKpD,SAAL,CACN;AACC6J,QAAAA,gBAAgB,EAAE,0BAAAqC,GAAG;AAAA,iBAAIlL,GAAG,CAACmL,aAAJ,CAAmBD,GAAnB,CAAJ;AAAA,SADtB;AAECpC,QAAAA,kBAAkB,EAAE,4BAAAL,GAAG;AAAA,iBAAIzI,GAAG,CAAC8I,kBAAJ,CAAwBL,GAAxB,CAAJ;AAAA;AAFxB,OADM,CAAP;AAOA;AAlqBF;AAAA;AAAA,qCAoqBmBgD,MApqBnB,EAoqB4B;AAE1B,aAAO,KAAKzM,SAAL,CACN;AACC6J,QAAAA,gBAAgB,EAAE,0BAAAqC,GAAG;AAAA,iBAAIO,MAAM,CAACN,aAAP,CAAsBD,GAAtB,CAAJ;AAAA,SADtB;AAECpC,QAAAA,kBAAkB,EAAE,4BAAAL,GAAG;AAAA,iBAAIA,GAAG,CAACiD,gBAAJ,CAAsBD,MAAtB,CAAJ;AAAA;AAFxB,OADM,CAAP;AAOA;AA7qBF;AAAA;AAAA,2CA+qByBvD,aA/qBzB,EA+qBwCyD,aA/qBxC,EA+qBiI;AAAA,UAA1EC,OAA0E,uEAAhE,EAAgE;AAAA,UAA3DC,OAA2D,uEAAjD,EAAiD;AAAA,UAA5CC,YAA4C,uEAA7B,CAA6B;AAAA,UAA1BC,YAA0B,uEAAX7G,QAAW;;AAE/H,UAAK,CAAEgD,aAAa,CAACjF,WAArB,EAAmC;AAElCiF,QAAAA,aAAa,CAAC8D,kBAAd;AAEA;;AAEDhM,MAAAA,GAAG,CAACmC,GAAJ,CAAS+F,aAAa,CAACjF,WAAd,CAA0BsI,GAAnC,EAAwCrD,aAAa,CAACjF,WAAd,CAA0BuI,GAAlE,EAAuEG,aAAvE;AACA3L,MAAAA,GAAG,CAACoC,WAAJ,GAAkB,IAAlB;AAEA,UAAMjB,QAAQ,GAAG,KAAKA,QAAtB;AACA,UAAM8K,GAAG,GAAG9K,QAAQ,CAACsC,UAAT,CAAoBC,QAAhC;AACA,UAAM7B,KAAK,GAAGV,QAAQ,CAACU,KAAvB;AACA,UAAMqK,QAAQ,GAAGhE,aAAa,CAACzE,UAAd,CAAyBC,QAA1C;AACA,UAAMyI,UAAU,GAAGjE,aAAa,CAACrG,KAAjC;AACA,UAAMmH,QAAQ,GAAGxI,YAAY,CAACyI,YAAb,EAAjB;AACA,UAAMc,SAAS,GAAGvJ,YAAY,CAACyI,YAAb,EAAlB;AAEA,UAAImD,WAAW,GAAGjM,KAAlB;AACA,UAAIkM,eAAe,GAAGjM,KAAtB;AACA,UAAIkM,WAAW,GAAG,IAAlB;AACA,UAAIC,eAAe,GAAG,IAAtB;;AAEA,UAAKV,OAAL,EAAe;AAEdS,QAAAA,WAAW,GAAGjM,KAAd;AACAkM,QAAAA,eAAe,GAAGjM,KAAlB;AAEA;;AAED,UAAIkM,eAAe,GAAGtH,QAAtB;AACA,UAAIuH,uBAAuB,GAAG,IAA9B;AACA,UAAIC,4BAA4B,GAAG,IAAnC;AACA3M,MAAAA,UAAU,CAAC8J,IAAX,CAAiB8B,aAAjB,EAAiC7B,MAAjC;AACA7J,MAAAA,IAAI,CAAC0M,MAAL,CAAY9C,IAAZ,CAAkB9J,UAAlB;AACA,WAAKf,SAAL,CACC;AAEC4J,QAAAA,mBAAmB,EAAE,6BAAAsC,GAAG,EAAI;AAE3B,iBAAOlL,GAAG,CAAC4M,aAAJ,CAAmB1B,GAAnB,CAAP;AAEA,SANF;AAQCrC,QAAAA,gBAAgB,EAAE,0BAAEqC,GAAF,EAAOnG,MAAP,EAAe8H,KAAf,EAA0B;AAE3C,cAAKA,KAAK,GAAGL,eAAR,IAA2BK,KAAK,GAAGd,YAAxC,EAAuD;AAEtD;AACA;AACA,gBAAKhH,MAAL,EAAc;AAEb9E,cAAAA,IAAI,CAACsL,GAAL,CAAS1B,IAAT,CAAeqB,GAAG,CAACK,GAAnB;AACAtL,cAAAA,IAAI,CAACuL,GAAL,CAAS3B,IAAT,CAAeqB,GAAG,CAACM,GAAnB;AACAvL,cAAAA,IAAI,CAACmC,WAAL,GAAmB,IAAnB;AAEA;;AAED,mBAAO,IAAP;AAEA;;AAED,iBAAO,KAAP;AAEA,SA5BF;AA8BC2G,QAAAA,eAAe,EAAE,yBAAElF,MAAF,EAAUmB,KAAV,EAAqB;AAErC,cAAKkD,aAAa,CAAC4E,UAAnB,EAAgC;AAE/B;AACA;AACA,mBAAO5E,aAAa,CAAC4E,UAAd,CAAyB9N,SAAzB,CAAoC;AAC1C4J,cAAAA,mBAAmB,EAAE,6BAAAsC,GAAG,EAAI;AAE3B,uBAAOjL,IAAI,CAAC2M,aAAL,CAAoB1B,GAApB,CAAP;AAEA,eALyC;AAO1CrC,cAAAA,gBAAgB,EAAE,0BAAEqC,GAAF,EAAOnG,MAAP,EAAe8H,KAAf,EAA0B;AAE3C,uBAAOA,KAAK,GAAGL,eAAR,IAA2BK,KAAK,GAAGd,YAA1C;AAEA,eAXyC;AAa1ChD,cAAAA,eAAe,EAAE,yBAAEgE,WAAF,EAAeC,UAAf,EAA+B;AAE/C,qBAAM,IAAIvC,EAAE,GAAGsC,WAAW,GAAG,CAAvB,EAA0BrC,EAAE,GAAG,CAAEqC,WAAW,GAAGC,UAAhB,IAA+B,CAApE,EAAuEvC,EAAE,GAAGC,EAA5E,EAAgFD,EAAE,IAAI,CAAtF,EAA0F;AAEzFhL,kBAAAA,WAAW,CAAEsK,SAAF,EAAaU,EAAb,EAAiB0B,UAAjB,EAA6BD,QAA7B,CAAX;AACAnC,kBAAAA,SAAS,CAACY,CAAV,CAAYC,YAAZ,CAA0Be,aAA1B;AACA5B,kBAAAA,SAAS,CAACc,CAAV,CAAYD,YAAZ,CAA0Be,aAA1B;AACA5B,kBAAAA,SAAS,CAACe,CAAV,CAAYF,YAAZ,CAA0Be,aAA1B;AACA5B,kBAAAA,SAAS,CAAC3H,WAAV,GAAwB,IAAxB;;AAEA,uBAAM,IAAIgC,CAAC,GAAGP,MAAM,GAAG,CAAjB,EAAoBQ,CAAC,GAAG,CAAER,MAAM,GAAGmB,KAAX,IAAqB,CAAnD,EAAsDZ,CAAC,GAAGC,CAA1D,EAA6DD,CAAC,IAAI,CAAlE,EAAsE;AAErE3E,oBAAAA,WAAW,CAAEuJ,QAAF,EAAY5E,CAAZ,EAAevC,KAAf,EAAsBoK,GAAtB,CAAX;AACAjD,oBAAAA,QAAQ,CAAC5G,WAAT,GAAuB,IAAvB;AAEA,wBAAM6K,IAAI,GAAGjE,QAAQ,CAACkE,kBAAT,CAA6BnD,SAA7B,EAAwCqC,WAAxC,EAAqDE,WAArD,CAAb;;AACA,wBAAKW,IAAI,GAAGT,eAAZ,EAA8B;AAE7BH,sBAAAA,eAAe,CAACxC,IAAhB,CAAsBuC,WAAtB;;AAEA,0BAAKG,eAAL,EAAuB;AAEtBA,wBAAAA,eAAe,CAAC1C,IAAhB,CAAsByC,WAAtB;AAEA;;AAEDE,sBAAAA,eAAe,GAAGS,IAAlB;AACAR,sBAAAA,uBAAuB,GAAGrI,CAAC,GAAG,CAA9B;AACAsI,sBAAAA,4BAA4B,GAAGjC,EAAE,GAAG,CAApC;AAEA,qBApBoE,CAsBrE;;;AACA,wBAAKwC,IAAI,GAAGnB,YAAZ,EAA2B;AAE1B,6BAAO,IAAP;AAEA;AAED;AAED;AAED;AAxDyC,aAApC,CAAP;AA2DA,WA/DD,MA+DO;AAEN;AACA,gBAAMqB,QAAQ,GAAGhB,UAAU,GAAGA,UAAU,CAACnH,KAAd,GAAsBkH,QAAQ,CAAClH,KAA1D;;AACA,iBAAM,IAAIyF,EAAE,GAAG,CAAT,EAAYC,EAAE,GAAGyC,QAAvB,EAAiC1C,EAAE,GAAGC,EAAtC,EAA0CD,EAAE,IAAI,CAAhD,EAAoD;AAEnDhL,cAAAA,WAAW,CAAEsK,SAAF,EAAaU,EAAb,EAAiB0B,UAAjB,EAA6BD,QAA7B,CAAX;AACAnC,cAAAA,SAAS,CAACY,CAAV,CAAYC,YAAZ,CAA0Be,aAA1B;AACA5B,cAAAA,SAAS,CAACc,CAAV,CAAYD,YAAZ,CAA0Be,aAA1B;AACA5B,cAAAA,SAAS,CAACe,CAAV,CAAYF,YAAZ,CAA0Be,aAA1B;AACA5B,cAAAA,SAAS,CAAC3H,WAAV,GAAwB,IAAxB;;AAEA,mBAAM,IAAIgC,CAAC,GAAGP,MAAM,GAAG,CAAjB,EAAoBQ,CAAC,GAAG,CAAER,MAAM,GAAGmB,KAAX,IAAqB,CAAnD,EAAsDZ,CAAC,GAAGC,CAA1D,EAA6DD,CAAC,IAAI,CAAlE,EAAsE;AAErE3E,gBAAAA,WAAW,CAAEuJ,QAAF,EAAY5E,CAAZ,EAAevC,KAAf,EAAsBoK,GAAtB,CAAX;AACAjD,gBAAAA,QAAQ,CAAC5G,WAAT,GAAuB,IAAvB;AAEA,oBAAM6K,IAAI,GAAGjE,QAAQ,CAACkE,kBAAT,CAA6BnD,SAA7B,EAAwCqC,WAAxC,EAAqDE,WAArD,CAAb;;AACA,oBAAKW,IAAI,GAAGT,eAAZ,EAA8B;AAE7BH,kBAAAA,eAAe,CAACxC,IAAhB,CAAsBuC,WAAtB;;AAEA,sBAAKG,eAAL,EAAuB;AAEtBA,oBAAAA,eAAe,CAAC1C,IAAhB,CAAsByC,WAAtB;AAEA;;AAEDE,kBAAAA,eAAe,GAAGS,IAAlB;AACAR,kBAAAA,uBAAuB,GAAGrI,CAAC,GAAG,CAA9B;AACAsI,kBAAAA,4BAA4B,GAAGjC,EAAE,GAAG,CAApC;AAEA,iBApBoE,CAsBrE;;;AACA,oBAAKwC,IAAI,GAAGnB,YAAZ,EAA2B;AAE1B,yBAAO,IAAP;AAEA;AAED;AAED;AAED;AAED;AA9IF,OADD;AAqJAtL,MAAAA,YAAY,CAAC4I,gBAAb,CAA+BJ,QAA/B;AACAxI,MAAAA,YAAY,CAAC4I,gBAAb,CAA+BW,SAA/B;AAEA,UAAKyC,eAAe,KAAKtH,QAAzB,EAAoC,OAAO,IAAP;AAEpC,UAAK,CAAE0G,OAAO,CAACwB,KAAf,EAAuBxB,OAAO,CAACwB,KAAR,GAAgBf,eAAe,CAACgB,KAAhB,EAAhB,CAAvB,KACKzB,OAAO,CAACwB,KAAR,CAAcvD,IAAd,CAAoBwC,eAApB;AACLT,MAAAA,OAAO,CAAC3D,QAAR,GAAmBuE,eAAnB,EACAZ,OAAO,CAAC0B,SAAR,GAAoBb,uBADpB;;AAGA,UAAKZ,OAAL,EAAe;AAEd,YAAK,CAAEA,OAAO,CAACuB,KAAf,EAAuBvB,OAAO,CAACuB,KAAR,GAAgBb,eAAe,CAACc,KAAhB,EAAhB,CAAvB,KACKxB,OAAO,CAACuB,KAAR,CAAcvD,IAAd,CAAoB0C,eAApB;AACLV,QAAAA,OAAO,CAACuB,KAAR,CAAcxC,YAAd,CAA4B7K,UAA5B;AACAsM,QAAAA,eAAe,CAACzB,YAAhB,CAA8B7K,UAA9B;AACA8L,QAAAA,OAAO,CAAC5D,QAAR,GAAmBoE,eAAe,CAACkB,GAAhB,CAAqB1B,OAAO,CAACuB,KAA7B,EAAqC9I,MAArC,EAAnB;AACAuH,QAAAA,OAAO,CAACyB,SAAR,GAAoBZ,4BAApB;AAEA;;AAED,aAAOd,OAAP;AAEA;AA/3BF;AAAA;AAAA,wCAi4BsBwB,KAj4BtB,EAi4BuF;AAAA,UAA1DI,MAA0D,uEAAjD,EAAiD;AAAA,UAA5C1B,YAA4C,uEAA7B,CAA6B;AAAA,UAA1BC,YAA0B,uEAAX7G,QAAW;AAErF;AACA;AACA;AACA;AACA,UAAMuI,cAAc,GAAG3B,YAAY,GAAGA,YAAtC;AACA,UAAM4B,cAAc,GAAG3B,YAAY,GAAGA,YAAtC;AACA,UAAI4B,iBAAiB,GAAGzI,QAAxB;AACA,UAAIuH,uBAAuB,GAAG,IAA9B;AACA,WAAKzN,SAAL,CAEC;AAEC4J,QAAAA,mBAAmB,EAAE,6BAAAsC,GAAG,EAAI;AAE3BhL,UAAAA,IAAI,CAAC2J,IAAL,CAAWuD,KAAX,EAAmBQ,KAAnB,CAA0B1C,GAAG,CAACK,GAA9B,EAAmCL,GAAG,CAACM,GAAvC;AACA,iBAAOtL,IAAI,CAAC2N,iBAAL,CAAwBT,KAAxB,CAAP;AAEA,SAPF;AASCvE,QAAAA,gBAAgB,EAAE,0BAAEqC,GAAF,EAAOnG,MAAP,EAAe8H,KAAf,EAA0B;AAE3C,iBAAOA,KAAK,GAAGc,iBAAR,IAA6Bd,KAAK,GAAGa,cAA5C;AAEA,SAbF;AAeC5E,QAAAA,kBAAkB,EAAE,4BAAEL,GAAF,EAAOqF,QAAP,EAAqB;AAExCrF,UAAAA,GAAG,CAACsF,mBAAJ,CAAyBX,KAAzB,EAAgClN,IAAhC;AACA,cAAM8N,MAAM,GAAGZ,KAAK,CAACS,iBAAN,CAAyB3N,IAAzB,CAAf;;AACA,cAAK8N,MAAM,GAAGL,iBAAd,EAAkC;AAEjCxN,YAAAA,KAAK,CAAC0J,IAAN,CAAY3J,IAAZ;AACAyN,YAAAA,iBAAiB,GAAGK,MAApB;AACAvB,YAAAA,uBAAuB,GAAGqB,QAA1B;AAEA;;AAED,cAAKE,MAAM,GAAGP,cAAd,EAA+B;AAE9B,mBAAO,IAAP;AAEA,WAJD,MAIO;AAEN,mBAAO,KAAP;AAEA;AAED;AArCF,OAFD;AA6CA,UAAKE,iBAAiB,KAAKzI,QAA3B,EAAsC,OAAO,IAAP;AAEtC,UAAMsH,eAAe,GAAGyB,IAAI,CAACC,IAAL,CAAWP,iBAAX,CAAxB;AAEA,UAAK,CAAEH,MAAM,CAACJ,KAAd,EAAsBI,MAAM,CAACJ,KAAP,GAAejN,KAAK,CAACkN,KAAN,EAAf,CAAtB,KACKG,MAAM,CAACJ,KAAP,CAAavD,IAAb,CAAmB1J,KAAnB;AACLqN,MAAAA,MAAM,CAACvF,QAAP,GAAkBuE,eAAlB,EACAgB,MAAM,CAACF,SAAP,GAAmBb,uBADnB;AAGA,aAAOe,MAAP;AAEA;AAn8BF;AAAA;AAAA,mCAq8BiBA,MAr8BjB,EAq8B0B;AAExBA,MAAAA,MAAM,CAACW,SAAP;AAEA,UAAM1M,KAAK,GAAG,KAAKJ,MAAnB;AACAI,MAAAA,KAAK,CAAC2M,OAAN,CAAe,UAAArK,MAAM,EAAI;AAExBxE,QAAAA,UAAU,CAAE,CAAF,EAAK,IAAIkF,YAAJ,CAAkBV,MAAlB,CAAL,EAAiCxD,OAAjC,CAAV;AACAiN,QAAAA,MAAM,CAACa,KAAP,CAAc9N,OAAd;AAEA,OALD;AAOA,aAAOiN,MAAP;AAEA;AAn9BF;;AAAA;AAAA,I,CAu9BA;;AACA,IAAMc,eAAe,GAAG7N,OAAO,CAAC8N,SAAR,CAAkBzP,OAA1C;;AACA2B,OAAO,CAAC8N,SAAR,CAAkBzP,OAAlB,GAA4B,YAAqB;AAAA,oCAAP0P,IAAO;AAAPA,IAAAA,IAAO;AAAA;;AAEhD,MAAKA,IAAI,CAAE,CAAF,CAAJ,CAAUC,MAAf,EAAwB;AAEvB5N,IAAAA,OAAO,CAACC,IAAR,CAAc,0GAAd;AAFuB,QAItB4N,IAJsB,GAKnBF,IALmB;AAAA,QAIhBG,SAJgB,GAKnBH,IALmB;AAAA,QAILrH,GAJK,GAKnBqH,IALmB;AAAA,QAIAnH,UAJA,GAKnBmH,IALmB;AAOvB,QAAMI,OAAO,GAAGN,eAAe,CAACO,IAAhB,CAAsB,IAAtB,EAA4B1H,GAA5B,EAAiCuH,IAAI,CAACI,QAAtC,CAAhB;AACAF,IAAAA,OAAO,CAACR,OAAR,CAAiB,UAAAW,GAAG,EAAI;AAEvBA,MAAAA,GAAG,GAAGrP,uBAAuB,CAAEqP,GAAF,EAAOL,IAAP,EAAaC,SAAb,CAA7B;;AACA,UAAKI,GAAL,EAAW;AAEV1H,QAAAA,UAAU,CAAC2H,IAAX,CAAiBD,GAAjB;AAEA;AAED,KATD;AAWA,WAAO1H,UAAP;AAEA,GArBD,MAqBO;AAEN,WAAOiH,eAAe,CAACW,KAAhB,CAAuB,IAAvB,EAA6BT,IAA7B,CAAP;AAEA;AAED,CA7BD;;AA+BA,IAAMU,oBAAoB,GAAGzO,OAAO,CAAC8N,SAAR,CAAkBxP,YAA/C;;AACA0B,OAAO,CAAC8N,SAAR,CAAkBxP,YAAlB,GAAiC,YAAqB;AAAA,qCAAPyP,IAAO;AAAPA,IAAAA,IAAO;AAAA;;AAErD,MAAKA,IAAI,CAAE,CAAF,CAAJ,CAAUC,MAAf,EAAwB;AAEvB5N,IAAAA,OAAO,CAACC,IAAR,CAAc,+GAAd;AAFuB,QAItB4N,IAJsB,GAKnBF,IALmB;AAAA,QAIhBG,SAJgB,GAKnBH,IALmB;AAAA,QAILrH,GAJK,GAKnBqH,IALmB;AAOvB,WAAO9O,uBAAuB,CAAEwP,oBAAoB,CAACL,IAArB,CAA2B,IAA3B,EAAiC1H,GAAjC,EAAsCuH,IAAI,CAACI,QAA3C,CAAF,EAAyDJ,IAAzD,EAA+DC,SAA/D,CAA9B;AAEA,GATD,MASO;AAEN,WAAOO,oBAAoB,CAACD,KAArB,CAA4B,IAA5B,EAAkCT,IAAlC,CAAP;AAEA;AAED,CAjBD;;AAmBA,IAAMW,2BAA2B,GAAG1O,OAAO,CAAC8N,SAAR,CAAkBR,mBAAtD;;AACAtN,OAAO,CAAC8N,SAAR,CAAkBR,mBAAlB,GAAwC,YAAqB;AAAA,qCAAPS,IAAO;AAAPA,IAAAA,IAAO;AAAA;;AAG5D,MAAKA,IAAI,CAAE,CAAF,CAAJ,CAAUC,MAAf,EAAwB;AAEvB5N,IAAAA,OAAO,CAACC,IAAR,CAAc,sHAAd;AAEA0N,IAAAA,IAAI,CAACY,OAAL;AAEA,QAAM5B,MAAM,GAAGgB,IAAI,CAAE,CAAF,CAAnB;AACA,QAAMhN,MAAM,GAAG,EAAf;AACAgN,IAAAA,IAAI,CAAE,CAAF,CAAJ,GAAYhN,MAAZ;AAEA2N,IAAAA,2BAA2B,CAACF,KAA5B,CAAmC,IAAnC,EAAyCT,IAAzC;;AAEA,QAAKhB,MAAL,EAAc;AAEbA,MAAAA,MAAM,CAAC3D,IAAP,CAAarI,MAAM,CAAC4L,KAApB;AAEA;;AAED,WAAO5L,MAAM,CAACyG,QAAd;AAEA,GApBD,MAoBO;AAEN,WAAOkH,2BAA2B,CAACF,KAA5B,CAAmC,IAAnC,EAAyCT,IAAzC,CAAP;AAEA;AAED,CA7BD;;AA+BA,IAAMa,8BAA8B,GAAG5O,OAAO,CAAC8N,SAAR,CAAkBe,sBAAzD;;AACA7O,OAAO,CAAC8N,SAAR,CAAkBe,sBAAlB,GAA2C,YAAqB;AAAA,qCAAPd,IAAO;AAAPA,IAAAA,IAAO;AAAA;;AAE/D,MAAM5C,OAAO,GAAG4C,IAAI,CAAE,CAAF,CAApB;AACA,MAAM3C,OAAO,GAAG2C,IAAI,CAAE,CAAF,CAApB;;AACA,MAAK5C,OAAO,IAAIA,OAAO,CAAC2D,SAAnB,IAAgC1D,OAAO,IAAIA,OAAO,CAAC0D,SAAxD,EAAoE;AAEnE1O,IAAAA,OAAO,CAACC,IAAR,CAAc,yHAAd;AAEA,QAAM0O,OAAO,GAAG,EAAhB;AACA,QAAMC,OAAO,GAAG,EAAhB;AACA,QAAM9D,aAAa,GAAG6C,IAAI,CAAE,CAAF,CAA1B;AACAA,IAAAA,IAAI,CAAE,CAAF,CAAJ,GAAYgB,OAAZ;AACAhB,IAAAA,IAAI,CAAE,CAAF,CAAJ,GAAYiB,OAAZ;AAEAJ,IAAAA,8BAA8B,CAACJ,KAA/B,CAAsC,IAAtC,EAA4CT,IAA5C;;AAEA,QAAK5C,OAAL,EAAe;AAEdA,MAAAA,OAAO,CAAC/B,IAAR,CAAc2F,OAAO,CAACpC,KAAtB;AAEA;;AAED,QAAKvB,OAAL,EAAe;AAEdA,MAAAA,OAAO,CAAChC,IAAR,CAAc4F,OAAO,CAACrC,KAAtB,EAA8BxC,YAA9B,CAA4Ce,aAA5C;AAEA;;AAED,WAAO6D,OAAO,CAACvH,QAAf;AAEA,GA1BD,MA0BO;AAEN,WAAOoH,8BAA8B,CAACJ,KAA/B,CAAsC,IAAtC,EAA4CT,IAA5C,CAAP;AAEA;AAED,CApCD;;AAsCA,IAAMkB,aAAa,GAAGjP,OAAO,CAAC8N,SAAR,CAAkBoB,KAAxC;;AACAlP,OAAO,CAAC8N,SAAR,CAAkBoB,KAAlB,GAA0B,YAAqB;AAAA,qCAAPnB,IAAO;AAAPA,IAAAA,IAAO;AAAA;;AAE9C,MAAMrL,WAAW,GAAGqL,IAAI,CAAE,CAAF,CAAxB;AACA,MAAMoB,kBAAkB,GAAGpB,IAAI,CAAE,CAAF,CAA/B;;AACA,MAAKoB,kBAAkB,KAAMA,kBAAkB,YAAYtM,GAA9B,IAAqCF,KAAK,CAACC,OAAN,CAAeuM,kBAAf,CAA3C,CAAvB,EAA0G;AAEzG/O,IAAAA,OAAO,CAACC,IAAR,CAAc,sFAAd;AAEA,QAAM+O,cAAc,GAAG,IAAIvM,GAAJ,EAAvB;AACAsM,IAAAA,kBAAkB,CAACxB,OAAnB,CAA4B,UAAA0B,CAAC;AAAA,aAAID,cAAc,CAACE,GAAf,CAAoBD,CAApB,CAAJ;AAAA,KAA7B;;AACA,QAAK3M,WAAL,EAAmB;AAElBA,MAAAA,WAAW,CAACiL,OAAZ,CAAqB,UAAA0B,CAAC;AAAA,eAAID,cAAc,CAACE,GAAf,CAAoBD,CAApB,CAAJ;AAAA,OAAtB;AAEA;;AAEDJ,IAAAA,aAAa,CAACb,IAAd,CAAoB,IAApB,EAA0BgB,cAA1B;AAEA,GAdD,MAcO;AAENH,IAAAA,aAAa,CAACT,KAAd,CAAqB,IAArB,EAA2BT,IAA3B;AAEA;AAED,CAxBD;;AA0BA,CACC,oBADD,EAEC,WAFD,EAGC,eAHD,EAIC,kBAJD,EAKEJ,OALF,CAKW,UAAA4B,IAAI,EAAI;AAElB,MAAMC,YAAY,GAAGxP,OAAO,CAAC8N,SAAR,CAAmByB,IAAnB,CAArB;;AACAvP,EAAAA,OAAO,CAAC8N,SAAR,CAAmByB,IAAnB,IAA4B,YAAqB;AAAA,uCAAPxB,IAAO;AAAPA,MAAAA,IAAO;AAAA;;AAEhD,QAAKA,IAAI,CAAE,CAAF,CAAJ,KAAc,IAAd,IAAsBA,IAAI,CAAE,CAAF,CAAJ,CAAUC,MAArC,EAA8C;AAE7CD,MAAAA,IAAI,CAAC0B,KAAL;AACArP,MAAAA,OAAO,CAACC,IAAR,iDAAuDkP,IAAvD;AAEA;;AAED,WAAOC,YAAY,CAAChB,KAAb,CAAoB,IAApB,EAA0BT,IAA1B,CAAP;AAEA,GAXD;AAaA,CArBD","sourcesContent":["import { Vector3, BufferAttribute, Box3, FrontSide, Matrix4 } from 'three';\r\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG } from './Constants.js';\r\nimport { buildPackedTree } from './buildFunctions.js';\r\nimport {\r\n\traycast,\r\n\traycastFirst,\r\n\tshapecast,\r\n\tintersectsGeometry,\r\n\tsetBuffer,\r\n\tclearBuffer,\r\n} from './castFunctions.js';\r\nimport { OrientedBox } from '../math/OrientedBox.js';\r\nimport { SeparatingAxisTriangle } from '../math/SeparatingAxisTriangle.js';\r\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\r\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\r\nimport { iterateOverTriangles, setTriangle } from '../utils/TriangleUtilities.js';\r\nimport { convertRaycastIntersect } from '../utils/GeometryRayIntersectUtilities.js';\r\n\r\nconst SKIP_GENERATION = Symbol( 'skip tree generation' );\r\n\r\nconst aabb = /* @__PURE__ */ new Box3();\r\nconst aabb2 = /* @__PURE__ */ new Box3();\r\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\r\nconst obb = /* @__PURE__ */ new OrientedBox();\r\nconst obb2 = /* @__PURE__ */ new OrientedBox();\r\nconst temp = /* @__PURE__ */ new Vector3();\r\nconst temp1 = /* @__PURE__ */ new Vector3();\r\nconst temp2 = /* @__PURE__ */ new Vector3();\r\nconst temp3 = /* @__PURE__ */ new Vector3();\r\nconst temp4 = /* @__PURE__ */ new Vector3();\r\nconst tempBox = /* @__PURE__ */ new Box3();\r\nconst trianglePool = /* @__PURE__ */ new PrimitivePool( () => new SeparatingAxisTriangle() );\r\n\r\nexport class MeshBVH {\r\n\r\n\tstatic serialize( bvh, options = {} ) {\r\n\r\n\t\tif ( options.isBufferGeometry ) {\r\n\r\n\t\t\tconsole.warn( 'MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature.' );\r\n\r\n\t\t\treturn MeshBVH.serialize(\r\n\t\t\t\targuments[ 0 ],\r\n\t\t\t\t{\r\n\t\t\t\t\tcloneBuffers: arguments[ 2 ] === undefined ? true : arguments[ 2 ],\r\n\t\t\t\t}\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\toptions = {\r\n\t\t\tcloneBuffers: true,\r\n\t\t\t...options,\r\n\t\t};\r\n\r\n\t\tconst geometry = bvh.geometry;\r\n\t\tconst rootData = bvh._roots;\r\n\t\tconst indexAttribute = geometry.getIndex();\r\n\t\tlet result;\r\n\t\tif ( options.cloneBuffers ) {\r\n\r\n\t\t\tresult = {\r\n\t\t\t\troots: rootData.map( root => root.slice() ),\r\n\t\t\t\tindex: indexAttribute.array.slice(),\r\n\t\t\t};\r\n\r\n\t\t} else {\r\n\r\n\t\t\tresult = {\r\n\t\t\t\troots: rootData,\r\n\t\t\t\tindex: indexAttribute.array,\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tstatic deserialize( data, geometry, options = {} ) {\r\n\r\n\t\tif ( typeof options === 'boolean' ) {\r\n\r\n\t\t\tconsole.warn( 'MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature.' );\r\n\r\n\t\t\treturn MeshBVH.deserialize(\r\n\t\t\t\targuments[ 0 ],\r\n\t\t\t\targuments[ 1 ],\r\n\t\t\t\t{\r\n\t\t\t\t\tsetIndex: arguments[ 2 ] === undefined ? true : arguments[ 2 ],\r\n\t\t\t\t}\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\toptions = {\r\n\t\t\tsetIndex: true,\r\n\t\t\t...options,\r\n\t\t};\r\n\r\n\t\tconst { index, roots } = data;\r\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\r\n\t\tbvh._roots = roots;\r\n\r\n\t\tif ( options.setIndex ) {\r\n\r\n\t\t\tconst indexAttribute = geometry.getIndex();\r\n\t\t\tif ( indexAttribute === null ) {\r\n\r\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\r\n\t\t\t\tgeometry.setIndex( newIndex );\r\n\r\n\t\t\t} else if ( indexAttribute.array !== index ) {\r\n\r\n\t\t\t\tindexAttribute.array.set( index );\r\n\t\t\t\tindexAttribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn bvh;\r\n\r\n\t}\r\n\r\n\tconstructor( geometry, options = {} ) {\r\n\r\n\t\tif ( ! geometry.isBufferGeometry ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\r\n\r\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\r\n\r\n\t\t}\r\n\r\n\t\t// default options\r\n\t\toptions = Object.assign( {\r\n\r\n\t\t\tstrategy: CENTER,\r\n\t\t\tmaxDepth: 40,\r\n\t\t\tmaxLeafTris: 10,\r\n\t\t\tverbose: true,\r\n\t\t\tuseSharedArrayBuffer: false,\r\n\t\t\tsetBoundingBox: true,\r\n\t\t\tonProgress: null,\r\n\r\n\t\t\t// undocumented options\r\n\r\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\r\n\t\t\t[ SKIP_GENERATION ]: false,\r\n\r\n\t\t}, options );\r\n\r\n\t\tif ( options.useSharedArrayBuffer && typeof SharedArrayBuffer === 'undefined' ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\r\n\r\n\t\t}\r\n\r\n\t\tthis._roots = null;\r\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\r\n\r\n\t\t\tthis._roots = buildPackedTree( geometry, options );\r\n\r\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\r\n\r\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// retain references to the geometry so we can use them it without having to\r\n\t\t// take a geometry reference in every function.\r\n\t\tthis.geometry = geometry;\r\n\r\n\t}\r\n\r\n\trefit( nodeIndices = null ) {\r\n\r\n\t\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\r\n\r\n\t\t\tnodeIndices = new Set( nodeIndices );\r\n\r\n\t\t}\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst indexArr = geometry.index.array;\r\n\t\tconst posAttr = geometry.attributes.position;\r\n\t\tconst posArr = posAttr.array;\r\n\r\n\t\t// support for an interleaved position buffer\r\n\t\tconst bufferOffset = posAttr.offset || 0;\r\n\t\tlet stride = 3;\r\n\t\tif ( posAttr.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tstride = posAttr.data.stride;\r\n\r\n\t\t}\r\n\r\n\t\tlet buffer, uint32Array, uint16Array, float32Array;\r\n\t\tlet byteOffset = 0;\r\n\t\tconst roots = this._roots;\r\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\r\n\r\n\t\t\tbuffer = roots[ i ];\r\n\t\t\tuint32Array = new Uint32Array( buffer );\r\n\t\t\tuint16Array = new Uint16Array( buffer );\r\n\t\t\tfloat32Array = new Float32Array( buffer );\r\n\r\n\t\t\t_traverse( 0, byteOffset );\r\n\t\t\tbyteOffset += buffer.byteLength;\r\n\r\n\t\t}\r\n\r\n\t\tfunction _traverse( node32Index, byteOffset, force = false ) {\r\n\r\n\t\t\tconst node16Index = node32Index * 2;\r\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\r\n\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\r\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\r\n\r\n\t\t\t\tlet minx = Infinity;\r\n\t\t\t\tlet miny = Infinity;\r\n\t\t\t\tlet minz = Infinity;\r\n\t\t\t\tlet maxx = - Infinity;\r\n\t\t\t\tlet maxy = - Infinity;\r\n\t\t\t\tlet maxz = - Infinity;\r\n\t\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\r\n\r\n\t\t\t\t\tconst index = indexArr[ i ] * stride + bufferOffset;\r\n\t\t\t\t\tconst x = posArr[ index + 0 ];\r\n\t\t\t\t\tconst y = posArr[ index + 1 ];\r\n\t\t\t\t\tconst z = posArr[ index + 2 ];\r\n\r\n\t\t\t\t\tif ( x < minx ) minx = x;\r\n\t\t\t\t\tif ( x > maxx ) maxx = x;\r\n\r\n\t\t\t\t\tif ( y < miny ) miny = y;\r\n\t\t\t\t\tif ( y > maxy ) maxy = y;\r\n\r\n\t\t\t\t\tif ( z < minz ) minz = z;\r\n\t\t\t\t\tif ( z > maxz ) maxz = z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (\r\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\r\n\r\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\r\n\t\t\t\t) {\r\n\r\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\r\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\r\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\r\n\r\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\r\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\r\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconst left = node32Index + 8;\r\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\r\n\r\n\t\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\r\n\t\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\r\n\t\t\t\tconst offsetLeft = left + byteOffset;\r\n\t\t\t\tconst offsetRight = right + byteOffset;\r\n\t\t\t\tlet forceChildren = force;\r\n\t\t\t\tlet includesLeft = false;\r\n\t\t\t\tlet includesRight = false;\r\n\r\n\t\t\t\tif ( nodeIndices ) {\r\n\r\n\t\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\r\n\t\t\t\t\t// then we assume that all children need to be updated.\r\n\t\t\t\t\tif ( ! forceChildren ) {\r\n\r\n\t\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\r\n\t\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\r\n\t\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tincludesLeft = true;\r\n\t\t\t\t\tincludesRight = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst traverseLeft = forceChildren || includesLeft;\r\n\t\t\t\tconst traverseRight = forceChildren || includesRight;\r\n\r\n\t\t\t\tlet leftChange = false;\r\n\t\t\t\tif ( traverseLeft ) {\r\n\r\n\t\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet rightChange = false;\r\n\t\t\t\tif ( traverseRight ) {\r\n\r\n\t\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst didChange = leftChange || rightChange;\r\n\t\t\t\tif ( didChange ) {\r\n\r\n\t\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tconst lefti = left + i;\r\n\t\t\t\t\t\tconst righti = right + i;\r\n\t\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\r\n\t\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\r\n\t\t\t\t\t\tconst minRightValue = float32Array[ righti ];\r\n\t\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\r\n\r\n\t\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\r\n\t\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn didChange;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ttraverse( callback, rootIndex = 0 ) {\r\n\r\n\t\tconst buffer = this._roots[ rootIndex ];\r\n\t\tconst uint32Array = new Uint32Array( buffer );\r\n\t\tconst uint16Array = new Uint16Array( buffer );\r\n\t\t_traverse( 0 );\r\n\r\n\t\tfunction _traverse( node32Index, depth = 0 ) {\r\n\r\n\t\t\tconst node16Index = node32Index * 2;\r\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\r\n\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\r\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\r\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// TODO: use node functions here\r\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\r\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\r\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\r\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\r\n\r\n\t\t\t\tif ( ! stopTraversal ) {\r\n\r\n\t\t\t\t\t_traverse( left, depth + 1 );\r\n\t\t\t\t\t_traverse( right, depth + 1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/* Core Cast Functions */\r\n\traycast( ray, materialOrSide = FrontSide ) {\r\n\r\n\t\tconst roots = this._roots;\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst intersects = [];\r\n\t\tconst isMaterial = materialOrSide.isMaterial;\r\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\r\n\r\n\t\tconst groups = geometry.groups;\r\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\r\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\r\n\t\t\tconst startCount = intersects.length;\r\n\r\n\t\t\tsetBuffer( roots[ i ] );\r\n\t\t\traycast( 0, geometry, materialSide, ray, intersects );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t\tif ( isArrayMaterial ) {\r\n\r\n\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\r\n\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn intersects;\r\n\r\n\t}\r\n\r\n\traycastFirst( ray, materialOrSide = FrontSide ) {\r\n\r\n\t\tconst roots = this._roots;\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst isMaterial = materialOrSide.isMaterial;\r\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\r\n\r\n\t\tlet closestResult = null;\r\n\r\n\t\tconst groups = geometry.groups;\r\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\r\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\r\n\r\n\t\t\tsetBuffer( roots[ i ] );\r\n\t\t\tconst result = raycastFirst( 0, geometry, materialSide, ray );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\r\n\r\n\t\t\t\tclosestResult = result;\r\n\t\t\t\tif ( isArrayMaterial ) {\r\n\r\n\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn closestResult;\r\n\r\n\t}\r\n\r\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tlet result = false;\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tsetBuffer( root );\r\n\t\t\tresult = intersectsGeometry( 0, geometry, otherGeometry, geomToMesh );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t\tif ( result ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tshapecast( callbacks, _intersectsTriangleFunc, _orderNodesFunc ) {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tif ( callbacks instanceof Function ) {\r\n\r\n\t\t\tif ( _intersectsTriangleFunc ) {\r\n\r\n\t\t\t\t// Support the previous function signature that provided three sequential index buffer\r\n\t\t\t\t// indices here.\r\n\t\t\t\tconst originalTriangleFunc = _intersectsTriangleFunc;\r\n\t\t\t\t_intersectsTriangleFunc = ( tri, index, contained, depth ) => {\r\n\r\n\t\t\t\t\tconst i3 = index * 3;\r\n\t\t\t\t\treturn originalTriangleFunc( tri, i3, i3 + 1, i3 + 2, contained, depth );\r\n\r\n\t\t\t\t};\r\n\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcallbacks = {\r\n\r\n\t\t\t\tboundsTraverseOrder: _orderNodesFunc,\r\n\t\t\t\tintersectsBounds: callbacks,\r\n\t\t\t\tintersectsTriangle: _intersectsTriangleFunc,\r\n\t\t\t\tintersectsRange: null,\r\n\r\n\t\t\t};\r\n\r\n\t\t\tconsole.warn( 'MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.' );\r\n\r\n\t\t}\r\n\r\n\t\tconst triangle = trianglePool.getPrimitive();\r\n\t\tlet {\r\n\t\t\tboundsTraverseOrder,\r\n\t\t\tintersectsBounds,\r\n\t\t\tintersectsRange,\r\n\t\t\tintersectsTriangle,\r\n\t\t} = callbacks;\r\n\r\n\t\tif ( intersectsRange && intersectsTriangle ) {\r\n\r\n\t\t\tconst originalIntersectsRange = intersectsRange;\r\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\r\n\r\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\r\n\r\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t};\r\n\r\n\t\t} else if ( ! intersectsRange ) {\r\n\r\n\t\t\tif ( intersectsTriangle ) {\r\n\r\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\r\n\r\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\r\n\r\n\t\t\t\t\treturn contained;\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tlet result = false;\r\n\t\tlet byteOffset = 0;\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tsetBuffer( root );\r\n\t\t\tresult = shapecast( 0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t\tif ( result ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbyteOffset += root.byteLength;\r\n\r\n\t\t}\r\n\r\n\t\ttrianglePool.releasePrimitive( triangle );\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\r\n\r\n\t\t// BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather\r\n\t\t// than an approach that walks down the tree (see bvhcast.js file for more info).\r\n\r\n\t\tlet {\r\n\t\t\tintersectsRanges,\r\n\t\t\tintersectsTriangles,\r\n\t\t} = callbacks;\r\n\r\n\t\tconst indexAttr = this.geometry.index;\r\n\t\tconst positionAttr = this.geometry.attributes.position;\r\n\r\n\t\tconst otherIndexAttr = otherBvh.geometry.index;\r\n\t\tconst otherPositionAttr = otherBvh.geometry.attributes.position;\r\n\r\n\t\ttempMatrix.copy( matrixToLocal ).invert();\r\n\r\n\t\tconst triangle = trianglePool.getPrimitive();\r\n\t\tconst triangle2 = trianglePool.getPrimitive();\r\n\r\n\t\tif ( intersectsTriangles ) {\r\n\r\n\t\t\tfunction iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\r\n\r\n\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\r\n\r\n\t\t\t\t\tsetTriangle( triangle2, i2 * 3, otherIndexAttr, otherPositionAttr );\r\n\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\r\n\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\r\n\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\r\n\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\r\n\r\n\t\t\t\t\t\tsetTriangle( triangle, i1 * 3, indexAttr, positionAttr );\r\n\t\t\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\t\t\tif ( intersectsTriangles( triangle, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\r\n\r\n\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( intersectsRanges ) {\r\n\r\n\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\r\n\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\r\n\r\n\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\r\n\r\n\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.getBoundingBox( aabb2 );\r\n\t\taabb2.applyMatrix4( matrixToLocal );\r\n\t\tconst result = this.shapecast( {\r\n\r\n\t\t\tintersectsBounds: box => aabb2.intersectsBox( box ),\r\n\r\n\t\t\tintersectsRange: ( offset1, count1, contained, depth1, nodeIndex1, box ) => {\r\n\r\n\t\t\t\taabb.copy( box );\r\n\t\t\t\taabb.applyMatrix4( tempMatrix );\r\n\t\t\t\treturn otherBvh.shapecast( {\r\n\r\n\t\t\t\t\tintersectsBounds: box => aabb.intersectsBox( box ),\r\n\r\n\t\t\t\t\tintersectsRange: ( offset2, count2, contained, depth2, nodeIndex2 ) => {\r\n\r\n\t\t\t\t\t\treturn intersectsRanges( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 );\r\n\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\ttrianglePool.releasePrimitive( triangle );\r\n\t\ttrianglePool.releasePrimitive( triangle2 );\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\t/* Derived Cast Functions */\r\n\tintersectsBox( box, boxToMesh ) {\r\n\r\n\t\tobb.set( box.min, box.max, boxToMesh );\r\n\t\tobb.needsUpdate = true;\r\n\r\n\t\treturn this.shapecast(\r\n\t\t\t{\r\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\r\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tintersectsSphere( sphere ) {\r\n\r\n\t\treturn this.shapecast(\r\n\t\t\t{\r\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\r\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\r\n\r\n\t\tif ( ! otherGeometry.boundingBox ) {\r\n\r\n\t\t\totherGeometry.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\r\n\t\tobb.needsUpdate = true;\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst pos = geometry.attributes.position;\r\n\t\tconst index = geometry.index;\r\n\t\tconst otherPos = otherGeometry.attributes.position;\r\n\t\tconst otherIndex = otherGeometry.index;\r\n\t\tconst triangle = trianglePool.getPrimitive();\r\n\t\tconst triangle2 = trianglePool.getPrimitive();\r\n\r\n\t\tlet tempTarget1 = temp1;\r\n\t\tlet tempTargetDest1 = temp2;\r\n\t\tlet tempTarget2 = null;\r\n\t\tlet tempTargetDest2 = null;\r\n\r\n\t\tif ( target2 ) {\r\n\r\n\t\t\ttempTarget2 = temp3;\r\n\t\t\ttempTargetDest2 = temp4;\r\n\r\n\t\t}\r\n\r\n\t\tlet closestDistance = Infinity;\r\n\t\tlet closestDistanceTriIndex = null;\r\n\t\tlet closestDistanceOtherTriIndex = null;\r\n\t\ttempMatrix.copy( geometryToBvh ).invert();\r\n\t\tobb2.matrix.copy( tempMatrix );\r\n\t\tthis.shapecast(\r\n\t\t\t{\r\n\r\n\t\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\t\treturn obb.distanceToBox( box );\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\r\n\r\n\t\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\r\n\t\t\t\t\t\t// save the bounds to use during triangle checks.\r\n\t\t\t\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\t\t\t\tobb2.min.copy( box.min );\r\n\t\t\t\t\t\t\tobb2.max.copy( box.max );\r\n\t\t\t\t\t\t\tobb2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsRange: ( offset, count ) => {\r\n\r\n\t\t\t\t\tif ( otherGeometry.boundsTree ) {\r\n\r\n\t\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\r\n\t\t\t\t\t\t// the closest bounds in the other geometry to check.\r\n\t\t\t\t\t\treturn otherGeometry.boundsTree.shapecast( {\r\n\t\t\t\t\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\r\n\r\n\t\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\r\n\r\n\t\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\r\n\r\n\t\t\t\t\t\t\t\tfor ( let i2 = otherOffset * 3, l2 = ( otherOffset + otherCount ) * 3; i2 < l2; i2 += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\r\n\t\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\r\n\t\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\r\n\t\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\r\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i / 3;\r\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2 / 3;\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\r\n\t\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\r\n\t\t\t\t\t\tconst triCount = otherIndex ? otherIndex.count : otherPos.count;\r\n\t\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 += 3 ) {\r\n\r\n\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\r\n\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\r\n\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\r\n\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\r\n\r\n\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\r\n\r\n\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tclosestDistance = dist;\r\n\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i / 3;\r\n\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2 / 3;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\r\n\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\r\n\r\n\t\t\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t}\r\n\r\n\t\t);\r\n\r\n\t\ttrianglePool.releasePrimitive( triangle );\r\n\t\ttrianglePool.releasePrimitive( triangle2 );\r\n\r\n\t\tif ( closestDistance === Infinity ) return null;\r\n\r\n\t\tif ( ! target1.point ) target1.point = tempTargetDest1.clone();\r\n\t\telse target1.point.copy( tempTargetDest1 );\r\n\t\ttarget1.distance = closestDistance,\r\n\t\ttarget1.faceIndex = closestDistanceTriIndex;\r\n\r\n\t\tif ( target2 ) {\r\n\r\n\t\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\r\n\t\t\telse target2.point.copy( tempTargetDest2 );\r\n\t\t\ttarget2.point.applyMatrix4( tempMatrix );\r\n\t\t\ttempTargetDest1.applyMatrix4( tempMatrix );\r\n\t\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\r\n\t\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\r\n\r\n\t\t}\r\n\r\n\t\treturn target1;\r\n\r\n\t}\r\n\r\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\r\n\r\n\t\t// early out if under minThreshold\r\n\t\t// skip checking if over maxThreshold\r\n\t\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\r\n\t\t// returns Infinity if no value found\r\n\t\tconst minThresholdSq = minThreshold * minThreshold;\r\n\t\tconst maxThresholdSq = maxThreshold * maxThreshold;\r\n\t\tlet closestDistanceSq = Infinity;\r\n\t\tlet closestDistanceTriIndex = null;\r\n\t\tthis.shapecast(\r\n\r\n\t\t\t{\r\n\r\n\t\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\r\n\t\t\t\t\treturn temp.distanceToSquared( point );\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsTriangle: ( tri, triIndex ) => {\r\n\r\n\t\t\t\t\ttri.closestPointToPoint( point, temp );\r\n\t\t\t\t\tconst distSq = point.distanceToSquared( temp );\r\n\t\t\t\t\tif ( distSq < closestDistanceSq ) {\r\n\r\n\t\t\t\t\t\ttemp1.copy( temp );\r\n\t\t\t\t\t\tclosestDistanceSq = distSq;\r\n\t\t\t\t\t\tclosestDistanceTriIndex = triIndex;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( distSq < minThresholdSq ) {\r\n\r\n\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t}\r\n\r\n\t\t);\r\n\r\n\t\tif ( closestDistanceSq === Infinity ) return null;\r\n\r\n\t\tconst closestDistance = Math.sqrt( closestDistanceSq );\r\n\r\n\t\tif ( ! target.point ) target.point = temp1.clone();\r\n\t\telse target.point.copy( temp1 );\r\n\t\ttarget.distance = closestDistance,\r\n\t\ttarget.faceIndex = closestDistanceTriIndex;\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n\tgetBoundingBox( target ) {\r\n\r\n\t\ttarget.makeEmpty();\r\n\r\n\t\tconst roots = this._roots;\r\n\t\troots.forEach( buffer => {\r\n\r\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\r\n\t\t\ttarget.union( tempBox );\r\n\r\n\t\t} );\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Deprecation\r\nconst originalRaycast = MeshBVH.prototype.raycast;\r\nMeshBVH.prototype.raycast = function ( ...args ) {\r\n\r\n\tif ( args[ 0 ].isMesh ) {\r\n\r\n\t\tconsole.warn( 'MeshBVH: The function signature and results frame for \"raycast\" has changed. See docs for new signature.' );\r\n\t\tconst [\r\n\t\t\tmesh, raycaster, ray, intersects,\r\n\t\t] = args;\r\n\r\n\t\tconst results = originalRaycast.call( this, ray, mesh.material );\r\n\t\tresults.forEach( hit => {\r\n\r\n\t\t\thit = convertRaycastIntersect( hit, mesh, raycaster );\r\n\t\t\tif ( hit ) {\r\n\r\n\t\t\t\tintersects.push( hit );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\treturn intersects;\r\n\r\n\t} else {\r\n\r\n\t\treturn originalRaycast.apply( this, args );\r\n\r\n\t}\r\n\r\n};\r\n\r\nconst originalRaycastFirst = MeshBVH.prototype.raycastFirst;\r\nMeshBVH.prototype.raycastFirst = function ( ...args ) {\r\n\r\n\tif ( args[ 0 ].isMesh ) {\r\n\r\n\t\tconsole.warn( 'MeshBVH: The function signature and results frame for \"raycastFirst\" has changed. See docs for new signature.' );\r\n\t\tconst [\r\n\t\t\tmesh, raycaster, ray,\r\n\t\t] = args;\r\n\r\n\t\treturn convertRaycastIntersect( originalRaycastFirst.call( this, ray, mesh.material ), mesh, raycaster );\r\n\r\n\t} else {\r\n\r\n\t\treturn originalRaycastFirst.apply( this, args );\r\n\r\n\t}\r\n\r\n};\r\n\r\nconst originalClosestPointToPoint = MeshBVH.prototype.closestPointToPoint;\r\nMeshBVH.prototype.closestPointToPoint = function ( ...args ) {\r\n\r\n\r\n\tif ( args[ 0 ].isMesh ) {\r\n\r\n\t\tconsole.warn( 'MeshBVH: The function signature and results frame for \"closestPointToPoint\" has changed. See docs for new signature.' );\r\n\r\n\t\targs.unshift();\r\n\r\n\t\tconst target = args[ 1 ];\r\n\t\tconst result = {};\r\n\t\targs[ 1 ] = result;\r\n\r\n\t\toriginalClosestPointToPoint.apply( this, args );\r\n\r\n\t\tif ( target ) {\r\n\r\n\t\t\ttarget.copy( result.point );\r\n\r\n\t\t}\r\n\r\n\t\treturn result.distance;\r\n\r\n\t} else {\r\n\r\n\t\treturn originalClosestPointToPoint.apply( this, args );\r\n\r\n\t}\r\n\r\n};\r\n\r\nconst originalClosestPointToGeometry = MeshBVH.prototype.closestPointToGeometry;\r\nMeshBVH.prototype.closestPointToGeometry = function ( ...args ) {\r\n\r\n\tconst target1 = args[ 2 ];\r\n\tconst target2 = args[ 3 ];\r\n\tif ( target1 && target1.isVector3 || target2 && target2.isVector3 ) {\r\n\r\n\t\tconsole.warn( 'MeshBVH: The function signature and results frame for \"closestPointToGeometry\" has changed. See docs for new signature.' );\r\n\r\n\t\tconst result1 = {};\r\n\t\tconst result2 = {};\r\n\t\tconst geometryToBvh = args[ 1 ];\r\n\t\targs[ 2 ] = result1;\r\n\t\targs[ 3 ] = result2;\r\n\r\n\t\toriginalClosestPointToGeometry.apply( this, args );\r\n\r\n\t\tif ( target1 ) {\r\n\r\n\t\t\ttarget1.copy( result1.point );\r\n\r\n\t\t}\r\n\r\n\t\tif ( target2 ) {\r\n\r\n\t\t\ttarget2.copy( result2.point ).applyMatrix4( geometryToBvh );\r\n\r\n\t\t}\r\n\r\n\t\treturn result1.distance;\r\n\r\n\t} else {\r\n\r\n\t\treturn originalClosestPointToGeometry.apply( this, args );\r\n\r\n\t}\r\n\r\n};\r\n\r\nconst originalRefit = MeshBVH.prototype.refit;\r\nMeshBVH.prototype.refit = function ( ...args ) {\r\n\r\n\tconst nodeIndices = args[ 0 ];\r\n\tconst terminationIndices = args[ 1 ];\r\n\tif ( terminationIndices && ( terminationIndices instanceof Set || Array.isArray( terminationIndices ) ) ) {\r\n\r\n\t\tconsole.warn( 'MeshBVH: The function signature for \"refit\" has changed. See docs for new signature.' );\r\n\r\n\t\tconst newNodeIndices = new Set();\r\n\t\tterminationIndices.forEach( v => newNodeIndices.add( v ) );\r\n\t\tif ( nodeIndices ) {\r\n\r\n\t\t\tnodeIndices.forEach( v => newNodeIndices.add( v ) );\r\n\r\n\t\t}\r\n\r\n\t\toriginalRefit.call( this, newNodeIndices );\r\n\r\n\t} else {\r\n\r\n\t\toriginalRefit.apply( this, args );\r\n\r\n\t}\r\n\r\n};\r\n\r\n[\r\n\t'intersectsGeometry',\r\n\t'shapecast',\r\n\t'intersectsBox',\r\n\t'intersectsSphere',\r\n].forEach( name => {\r\n\r\n\tconst originalFunc = MeshBVH.prototype[ name ];\r\n\tMeshBVH.prototype[ name ] = function ( ...args ) {\r\n\r\n\t\tif ( args[ 0 ] === null || args[ 0 ].isMesh ) {\r\n\r\n\t\t\targs.shift();\r\n\t\t\tconsole.warn( `MeshBVH: The function signature for \"${ name }\" has changed and no longer takes Mesh. See docs for new signature.` );\r\n\r\n\t\t}\r\n\r\n\t\treturn originalFunc.apply( this, args );\r\n\r\n\t};\r\n\r\n} );\r\n"]},"metadata":{},"sourceType":"module"}